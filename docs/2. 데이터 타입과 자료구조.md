
# 2. 데이터 타입과 자료구조

---

## 2.1 왜 자료구조가 필요한가

앞 장에서 하나의 변수에 하나의 값을 저장하는 방법을 배웠습니다. 학생 한 명의 점수를 저장한다면 이것으로 충분합니다.

```python
score = 85
```

하지만 현실의 문제는 이보다 복잡합니다. 한 반에 30명의 학생이 있고, 각 학생의 점수를 저장해야 한다면 어떻게 할까요? 변수를 30개 만들까요?

```python
score1 = 85
score2 = 92
score3 = 78
# ... score30까지?
```

이런 방식은 비효율적이고, 관리도 어렵습니다. 평균을 계산하려면 30개 변수를 일일이 더해야 하고, 학생이 한 명 추가되면 코드를 다시 작성해야 합니다.

**자료구조(data structure)**는 이런 문제를 해결합니다. 여러 개의 데이터를 하나의 묶음으로 관리하고, 효율적으로 접근하고, 수정할 수 있게 해주는 방법입니다.

Python은 네 가지 주요 자료구조를 제공합니다.

1. **리스트(List):** 순서가 있고 변경 가능한 데이터 모음
2. **튜플(Tuple):** 순서가 있지만 변경 불가능한 데이터 모음
3. **딕셔너리(Dictionary):** 키와 값의 쌍으로 데이터를 저장
4. **집합(Set):** 순서가 없고 중복을 허용하지 않는 데이터 모음

데이터 분석에서 이들은 필수적입니다. NumPy 배열은 리스트의 확장이고, Pandas DataFrame은 딕셔너리와 리스트의 조합으로 이해할 수 있습니다. 이 장에서 배우는 개념들은 앞으로 모든 데이터 작업의 기초가 됩니다.

---

## 2.2 리스트(List)

### 2.2.1 리스트 생성과 접근

리스트는 대괄호 `[]`로 만들고, 쉼표로 요소를 구분합니다.

```python
scores = [85, 92, 78, 90, 88]
print(scores)
```

출력:

```
[85, 92, 78, 90, 88]
```

리스트는 다양한 타입의 데이터를 함께 저장할 수 있습니다.

```python
mixed = [1, "hello", 3.14, True]
print(mixed)
```

출력:

```
[1, 'hello', 3.14, True]
```

하지만 실무에서는 보통 같은 타입의 데이터를 담습니다. 학생 점수 리스트라면 모두 숫자, 이름 리스트라면 모두 문자열입니다.

**인덱싱:**

리스트의 각 요소는 **인덱스(index)**로 접근합니다. 인덱스는 0부터 시작합니다.

```python
scores = [85, 92, 78, 90, 88]

print(scores[0])   # 첫 번째 요소: 85
print(scores[1])   # 두 번째 요소: 92
print(scores[4])   # 다섯 번째 요소: 88
```

**음수 인덱스:**

뒤에서부터 접근할 때는 음수를 사용합니다. `-1`은 마지막 요소입니다.

```python
print(scores[-1])   # 마지막 요소: 88
print(scores[-2])   # 뒤에서 두 번째: 90
```

**인덱스 범위 초과:**

존재하지 않는 인덱스에 접근하면 `IndexError`가 발생합니다.

```python
print(scores[10])   # IndexError: list index out of range
```

### 2.2.2 슬라이싱(Slicing)

슬라이싱은 리스트의 일부분을 잘라내는 기능입니다. 문법은 `[시작:끝]`입니다. 시작 인덱스는 포함되지만, 끝 인덱스는 포함되지 않습니다.

```python
scores = [85, 92, 78, 90, 88]

print(scores[1:4])   # 인덱스 1, 2, 3 (4는 불포함)
```

출력:

```
[92, 78, 90]
```

**생략 형태:**

시작이나 끝을 생략하면 처음 또는 끝까지를 의미합니다.

```python
print(scores[:3])    # 처음부터 인덱스 2까지: [85, 92, 78]
print(scores[2:])    # 인덱스 2부터 끝까지: [78, 90, 88]
print(scores[:])     # 전체 복사: [85, 92, 78, 90, 88]
```

**간격 지정:**

`[시작:끝:간격]` 형태로 간격을 지정할 수 있습니다.

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[::2])    # 2칸씩 건너뛰기: [0, 2, 4, 6, 8]
print(numbers[1::2])   # 1부터 2칸씩: [1, 3, 5, 7, 9]
print(numbers[::-1])   # 역순: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

**리스트 복사:**

슬라이싱 `[:]`는 리스트를 복사하는 간단한 방법입니다.

```python
original = [1, 2, 3]
copy = original[:]
copy[0] = 999

print(original)   # [1, 2, 3] (원본은 변하지 않음)
print(copy)       # [999, 2, 3]
```

단순히 `copy = original`로 하면 같은 리스트를 가리키므로, 하나를 변경하면 둘 다 변합니다.

### 2.2.3 리스트 수정

**요소 변경:**

인덱스를 사용해 특정 요소를 변경할 수 있습니다.

```python
scores = [85, 92, 78, 90, 88]
scores[2] = 95
print(scores)   # [85, 92, 95, 90, 88]
```

**요소 추가:**

`.append()`: 리스트 끝에 요소 추가

```python
scores = [85, 92, 78]
scores.append(90)
print(scores)   # [85, 92, 78, 90]
```

`.insert()`: 특정 위치에 요소 삽입

```python
scores.insert(1, 88)   # 인덱스 1에 88 삽입
print(scores)   # [85, 88, 92, 78, 90]
```

**요소 삭제:**

`.remove()`: 값으로 삭제 (첫 번째 일치 항목만)

```python
scores = [85, 92, 78, 90, 78]
scores.remove(78)
print(scores)   # [85, 92, 90, 78] (첫 번째 78만 삭제)
```

`.pop()`: 인덱스로 삭제하고 반환 (인덱스 생략 시 마지막 요소)

```python
scores = [85, 92, 78, 90, 88]
last_score = scores.pop()
print(last_score)   # 88
print(scores)       # [85, 92, 78, 90]

second_score = scores.pop(1)
print(second_score)   # 92
print(scores)         # [85, 78, 90]
```

`del` 키워드: 인덱스나 슬라이스로 삭제

```python
scores = [85, 92, 78, 90, 88]
del scores[1]
print(scores)   # [85, 78, 90, 88]

del scores[1:3]
print(scores)   # [85, 88]
```

**리스트 확장:**

`.extend()`: 다른 리스트의 모든 요소를 추가

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.extend(list2)
print(list1)   # [1, 2, 3, 4, 5, 6]
```

`+` 연산자: 두 리스트를 합쳐 새 리스트 생성

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list3 = list1 + list2
print(list3)   # [1, 2, 3, 4, 5, 6]
print(list1)   # [1, 2, 3] (원본은 변하지 않음)
```

### 2.2.4 리스트 메서드

**`.sort()`: 리스트를 정렬 (원본 변경)**

```python
numbers = [3, 1, 4, 1, 5, 9, 2]
numbers.sort()
print(numbers)   # [1, 1, 2, 3, 4, 5, 9]
```

내림차순 정렬:

```python
numbers.sort(reverse=True)
print(numbers)   # [9, 5, 4, 3, 2, 1, 1]
```

**`sorted()`: 정렬된 새 리스트 반환 (원본 유지)**

```python
numbers = [3, 1, 4, 1, 5]
sorted_numbers = sorted(numbers)
print(sorted_numbers)   # [1, 1, 3, 4, 5]
print(numbers)          # [3, 1, 4, 1, 5] (원본 그대로)
```

**`.reverse()`: 리스트 순서 뒤집기**

```python
numbers = [1, 2, 3, 4, 5]
numbers.reverse()
print(numbers)   # [5, 4, 3, 2, 1]
```

**`.count()`: 특정 값이 몇 번 나타나는지**

```python
numbers = [1, 2, 2, 3, 2, 4]
print(numbers.count(2))   # 3
```

**`.index()`: 특정 값의 첫 번째 인덱스**

```python
numbers = [10, 20, 30, 40, 30]
print(numbers.index(30))   # 2 (첫 번째 30의 위치)
```

값이 없으면 `ValueError`가 발생합니다.

**`len()`: 리스트 길이**

```python
scores = [85, 92, 78, 90, 88]
print(len(scores))   # 5
```

### 2.2.5 리스트와 반복

**`in` 연산자: 요소가 리스트에 있는지 확인**

```python
scores = [85, 92, 78, 90, 88]

if 92 in scores:
    print("92점이 있습니다")   # 출력됨

if 100 in scores:
    print("100점이 있습니다")   # 출력 안 됨
```

반복문은 뒤에서 자세히 다루지만, 간단한 예제로 맛보기:

```python
scores = [85, 92, 78, 90, 88]

for score in scores:
    print(score)
```

출력:

```
85
92
78
90
88
```

**AI 활용 팁:**

리스트 조작이 복잡할 때 AI에게 물어보세요.

"리스트에서 짝수만 남기고 홀수는 모두 제거하는 코드 작성해줘"

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

AI가 제시하는 방법을 받은 후, "이 코드를 한 줄씩 설명해줘"라고 추가 질문하면 이해를 깊게 할 수 있습니다.

---

## 2.3 튜플(Tuple)

### 2.3.1 튜플의 특징

튜플은 리스트와 비슷하지만, **생성 후 변경할 수 없다(immutable)**는 차이가 있습니다. 소괄호 `()`로 만듭니다.

```python
coordinates = (10, 20)
print(coordinates)
```

출력:

```
(10, 20)
```

인덱싱과 슬라이싱은 리스트와 동일합니다.

```python
point = (3, 4, 5)
print(point[0])      # 3
print(point[1:3])    # (4, 5)
```

**불변성:**

튜플의 요소는 변경할 수 없습니다.

```python
point = (3, 4)
point[0] = 10   # TypeError: 'tuple' object does not support item assignment
```

요소를 추가하거나 삭제하는 것도 불가능합니다.

### 2.3.2 튜플 사용 사례

**변경되면 안 되는 데이터:**

좌표, RGB 색상 값, 날짜(년, 월, 일) 같은 데이터는 한 번 정해지면 바뀌지 않아야 합니다.

```python
rgb_red = (255, 0, 0)
birth_date = (1990, 5, 15)
```

**함수에서 여러 값 반환:**

함수가 여러 값을 반환할 때 튜플을 사용합니다. (함수는 뒤에서 자세히 다룹니다)

```python
def get_min_max(numbers):
    return min(numbers), max(numbers)

result = get_min_max([3, 1, 4, 1, 5])
print(result)   # (1, 5)
```

**딕셔너리의 키:**

리스트는 변경 가능해서 딕셔너리의 키로 사용할 수 없지만, 튜플은 가능합니다.

```python
locations = {
    (0, 0): "원점",
    (1, 0): "x축 위의 점",
    (0, 1): "y축 위의 점"
}
```

### 2.3.3 튜플 언패킹

튜플의 요소들을 여러 변수에 동시에 할당할 수 있습니다.

```python
point = (10, 20)
x, y = point

print(x)   # 10
print(y)   # 20
```

이것은 변수 값을 교환할 때 유용합니다. `a, b = b, a`는 먼저 우변의 `b, a`가 임시 튜플 `(10, 5)`를 생성한 후(Packing), 이 튜플의 값을 좌변의 `a, b`에 순서대로 할당(Unpacking)합니다. 

```python
a = 5
b = 10

# 전통적 방법 (임시 변수 필요)
temp = a
a = b
b = temp

# 튜플 언패킹 (한 줄로 가능)
a, b = b, a

print(a, b)   # 10 5
```

함수 반환 값도 언패킹할 수 있습니다.

```python
def get_min_max(numbers):
    return min(numbers), max(numbers)

minimum, maximum = get_min_max([3, 1, 4, 1, 5])
print(f"최솟값: {minimum}, 최댓값: {maximum}")
```

출력:

```
최솟값: 1, 최댓값: 5
```

---

## 2.4 딕셔너리(Dictionary)

### 2.4.1 딕셔너리의 개념

지금까지 본 리스트와 튜플은 인덱스(숫자)로 데이터에 접근했습니다. 하지만 실제 세계에서는 의미 있는 이름으로 데이터를 찾는 경우가 많습니다.

전화번호부를 생각해보세요. "3번째 사람의 전화번호"보다는 "김철수의 전화번호"라고 찾는 것이 자연스럽습니다. 딕셔너리는 이런 방식으로 데이터를 저장합니다.

딕셔너리는 **키(key)**와 **값(value)**의 쌍으로 이루어져 있습니다. 키를 통해 값에 접근합니다.

```python
phone_book = {
    "김철수": "010-1234-5678",
    "이영희": "010-8765-4321",
    "박민수": "010-1111-2222"
}
```

### 2.4.2 딕셔너리 생성과 접근

**딕셔너리 생성:**

중괄호 `{}`를 사용하고, `키: 값` 형태로 작성합니다.

```python
student = {
    "name": "Alice",
    "age": 20,
    "major": "Computer Science"
}
```

빈 딕셔너리:

```python
empty_dict = {}
# 또는
empty_dict = dict()
```

**값 접근:**

대괄호에 키를 넣어 값을 가져옵니다.

```python
student = {
    "name": "Alice",
    "age": 20,
    "major": "Computer Science"
}

print(student["name"])   # Alice
print(student["age"])    # 20
```

**`.get()` 메서드:**

존재하지 않는 키에 접근하면 `KeyError`가 발생합니다.

```python
print(student["grade"])   # KeyError: 'grade'
```

`.get()` 메서드를 사용하면 키가 없을 때 에러 대신 `None`을 반환합니다.

```python
print(student.get("grade"))   # None
```

기본값을 지정할 수도 있습니다.

```python
print(student.get("grade", "N/A"))   # N/A
```

### 2.4.3 딕셔너리 수정

**값 변경:**

```python
student = {
    "name": "Alice",
    "age": 20
}

student["age"] = 21
print(student)   # {'name': 'Alice', 'age': 21}
```

**새 키-값 추가:**

존재하지 않는 키에 값을 할당하면 새로 추가됩니다.

```python
student["major"] = "Physics"
print(student)   # {'name': 'Alice', 'age': 21, 'major': 'Physics'}
```

**키-값 삭제:**

`del` 키워드:

```python
del student["major"]
print(student)   # {'name': 'Alice', 'age': 21}
```

`.pop()`: 삭제하면서 값 반환

```python
age = student.pop("age")
print(age)       # 21
print(student)   # {'name': 'Alice'}
```

**`.update()`: 여러 항목 추가 또는 변경**

```python
student = {"name": "Alice", "age": 20}

student.update({"age": 21, "major": "Math", "grade": "A"})
print(student)
```

출력:

```
{'name': 'Alice', 'age': 21, 'major': 'Math', 'grade': 'A'}
```

### 2.4.4 딕셔너리 메서드

**`.keys()`: 모든 키 가져오기**

```python
student = {"name": "Alice", "age": 20, "major": "CS"}
keys = student.keys()
print(keys)   # dict_keys(['name', 'age', 'major'])
```

리스트로 변환:

```python
keys_list = list(student.keys())
print(keys_list)   # ['name', 'age', 'major']
```

**`.values()`: 모든 값 가져오기**

```python
values = student.values()
print(values)   # dict_values(['Alice', 20, 'CS'])
```

**`.items()`: 키-값 쌍 가져오기**

```python
items = student.items()
print(items)   # dict_items([('name', 'Alice'), ('age', 20), ('major', 'CS')])
```

반복문과 함께 자주 사용됩니다.

```python
for key, value in student.items():
    print(f"{key}: {value}")
```

출력:

```
name: Alice
age: 20
major: CS
```

**`in` 연산자: 키 존재 확인**

```python
if "name" in student:
    print("이름 정보가 있습니다")   # 출력됨

if "grade" in student:
    print("성적 정보가 있습니다")   # 출력 안 됨
```

### 2.4.5 중첩 딕셔너리

딕셔너리의 값으로 또 다른 딕셔너리를 사용할 수 있습니다. 복잡한 데이터 구조를 표현할 때 유용합니다.

```python
students = {
    "student1": {
        "name": "Alice",
        "scores": {"math": 90, "english": 85}
    },
    "student2": {
        "name": "Bob",
        "scores": {"math": 88, "english": 92}
    }
}
```

접근:

```python
print(students["student1"]["name"])           # Alice
print(students["student1"]["scores"]["math"]) # 90
```

**실습: 학생 정보 관리**

여러 학생의 정보를 저장하고 출력하는 코드:

```python
students = {
    "Alice": {"age": 20, "major": "CS", "gpa": 3.8},
    "Bob": {"age": 21, "major": "Math", "gpa": 3.6},
    "Charlie": {"age": 19, "major": "Physics", "gpa": 3.9}
}

# 모든 학생 정보 출력
for name, info in students.items():
    print(f"\n학생 이름: {name}")
    print(f"  나이: {info['age']}")
    print(f"  전공: {info['major']}")
    print(f"  학점: {info['gpa']}")
```

출력:

```
학생 이름: Alice
  나이: 20
  전공: CS
  학점: 3.8

학생 이름: Bob
  나이: 21
  전공: Math
  학점: 3.6

학생 이름: Charlie
  나이: 19
  전공: Physics
  학점: 3.9
```

---

## 2.5 집합(Set)

### 2.5.1 집합의 특징

집합(set)은 수학의 집합 개념과 동일합니다. 두 가지 핵심 특징이 있습니다.

1. **중복을 허용하지 않음**
2. **순서가 없음** (인덱싱 불가)

중괄호 `{}`로 만들거나 `set()` 함수를 사용합니다.

```python
numbers = {1, 2, 3, 4, 5}
print(numbers)   # {1, 2, 3, 4, 5}
```

중복된 값은 자동으로 제거됩니다.

```python
numbers = {1, 2, 2, 3, 3, 3, 4, 5}
print(numbers)   # {1, 2, 3, 4, 5}
```

빈 집합은 `set()`으로만 만들 수 있습니다. (`{}`는 빈 딕셔너리입니다)

```python
empty_set = set()
```

리스트를 집합으로 변환하면 중복 제거에 유용합니다.

```python
numbers = [1, 2, 2, 3, 3, 3, 4, 5]
unique_numbers = set(numbers)
print(unique_numbers)   # {1, 2, 3, 4, 5}
```

### 2.5.2 집합 연산

**합집합 (`|` 또는 `.union()`):**

```python
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1 | set2)           # {1, 2, 3, 4, 5}
print(set1.union(set2))      # {1, 2, 3, 4, 5}
```

**교집합 (`&` 또는 `.intersection()`):**

```python
print(set1 & set2)                # {3}
print(set1.intersection(set2))    # {3}
```

**차집합 (`-` 또는 `.difference()`):**

```python
print(set1 - set2)              # {1, 2}
print(set1.difference(set2))    # {1, 2}
```

**요소 추가 (`.add()`):**

```python
fruits = {"apple", "banana"}
fruits.add("cherry")
print(fruits)   # {'apple', 'banana', 'cherry'}
```

**요소 삭제 (`.remove()` 또는 `.discard()`):**

```python
fruits.remove("banana")
print(fruits)   # {'apple', 'cherry'}
```

`.remove()`는 요소가 없으면 에러가 발생하지만, `.discard()`는 무시합니다.

```python
fruits.discard("grape")   # 에러 없음
```

**활용 예: 중복 제거**

```python
emails = [
    "alice@example.com",
    "bob@example.com",
    "alice@example.com",
    "charlie@example.com",
    "bob@example.com"
]

unique_emails = list(set(emails))
print(unique_emails)
```

출력 (순서는 무작위):

```
['charlie@example.com', 'bob@example.com', 'alice@example.com']
```

---

## 2.6 자료구조 선택 가이드

어떤 상황에 어떤 자료구조를 써야 할까요?

|상황|자료구조|이유|
|---|---|---|
|학생 점수 목록|리스트|순서가 중요하고, 값을 추가/변경할 수 있어야 함|
|좌표 (x, y)|튜플|한 번 정해지면 바뀌지 않음|
|학생 이름으로 점수 찾기|딕셔너리|키(이름)로 값(점수)을 빠르게 검색|
|고유한 사용자 ID 목록|집합|중복 제거, 순서는 중요하지 않음|
|설문 응답자 목록|집합|중복 응답 방지|
|상품 재고 관리|딕셔너리|상품명(키)으로 재고량(값) 관리|
|시계열 데이터|리스트|시간 순서가 중요|

**판단 기준:**

1. **순서가 중요한가?** → 리스트 또는 튜플
2. **변경이 필요한가?** → 리스트 (변경 불가면 튜플)
3. **키로 값을 찾는가?** → 딕셔너리
4. **중복 제거가 필요한가?** → 집합

---

## 2.7 실습: 학생 성적 관리 시스템

### 2.7.1 요구사항

딕셔너리와 리스트를 조합해 여러 학생의 성적을 관리하는 프로그램을 만들어봅시다.

- 학생별로 여러 과목 점수 저장
- 각 학생의 평균 계산
- 전체 학생 중 최고/최저 평균 찾기

### 2.7.2 코드 작성

`student_grade.py` 파일을 만들고 다음 코드를 작성합니다.

```python
# 학생 성적 데이터
students = {
    "Alice": [85, 92, 78, 90, 88],
    "Bob": [92, 88, 84, 95, 91],
    "Charlie": [78, 85, 80, 75, 82],
    "Diana": [95, 98, 96, 94, 97]
}

print("=" * 50)
print("학생 성적 관리 시스템")
print("=" * 50)

# 각 학생의 평균 계산 및 저장
averages = {}

for name, scores in students.items():
    average = sum(scores) / len(scores)
    averages[name] = average
    
    print(f"\n{name}의 점수: {scores}")
    print(f"평균: {average:.2f}점")

# 최고/최저 평균 찾기
max_student = max(averages, key=averages.get)
min_student = min(averages, key=averages.get)

print("\n" + "=" * 50)
print(f"최고 평균: {max_student} ({averages[max_student]:.2f}점)")
print(f"최저 평균: {min_student} ({averages[min_student]:.2f}점)")
print("=" * 50)
```

실행 결과:

```
==================================================
학생 성적 관리 시스템
==================================================

Alice의 점수: [85, 92, 78, 90, 88]
평균: 86.60점

Bob의 점수: [92, 88, 84, 95, 91]
평균: 90.00점

Charlie의 점수: [78, 85, 80, 75, 82]
평균: 80.00점

Diana의 점수: [95, 98, 96, 94, 97]
평균: 96.00점

==================================================
최고 평균: Diana (96.00점)
최저 평균: Charlie (80.00점)
==================================================
```

**코드 설명:**

1. `students` 딕셔너리: 키는 학생 이름, 값은 점수 리스트
2. `for name, scores in students.items()`: 딕셔너리를 순회하며 이름과 점수 가져오기
3. `sum(scores)`: 리스트의 모든 값을 더함
4. `len(scores)`: 리스트의 길이 (과목 수)
5. `averages[name] = average`: 새 딕셔너리에 평균 저장
6. `max(averages, key=averages.get)`: 딕셔너리에서 값이 최대인 키 찾기

### 2.7.3 확장 아이디어

**AI 활용 팁:**

프로그램을 더 발전시키고 싶다면 AI에게 물어보세요.

"이 성적 관리 시스템에 어떤 기능을 추가하면 좋을까요?"

AI가 제안할 수 있는 기능들:

1. **과목별 평균:** 모든 학생의 수학 평균, 영어 평균 등
2. **성적 등급:** 평균에 따라 A, B, C 등급 부여
3. **사용자 입력:** 직접 학생과 점수를 입력받기
4. **파일 저장:** 결과를 텍스트 파일로 저장
5. **시각화:** 성적 그래프 그리기 (matplotlib 사용)

이런 기능들은 다음 장에서 배울 제어문(if)과 반복문(for, while), 그리고 함수를 사용하면 쉽게 구현할 수 있습니다.

**간단한 확장 예제: 등급 부여**

```python
# averages 딕셔너리가 이미 계산되어 있다고 가정

print("\n성적 등급:")
for name, avg in averages.items():
    if avg >= 90:
        grade = "A"
    elif avg >= 80:
        grade = "B"
    elif avg >= 70:
        grade = "C"
    else:
        grade = "D"
    
    print(f"{name}: {avg:.2f}점 ({grade})")
```

출력:

```
성적 등급:
Alice: 86.60점 (B)
Bob: 90.00점 (A)
Charlie: 80.00점 (B)
Diana: 96.00점 (A)
```

---

**이 장에서 배운 것:**

- 자료구조의 필요성과 Python의 주요 자료구조
- **리스트:** 생성, 인덱싱, 슬라이싱, 수정, 정렬, 주요 메서드
- **튜플:** 불변 특성, 언패킹, 사용 사례
- **딕셔너리:** 키-값 쌍, 접근, 수정, 주요 메서드, 중첩 구조
- **집합:** 중복 제거, 집합 연산 (합집합, 교집합, 차집합)
- 상황별 적합한 자료구조 선택 가이드
- 실습: 딕셔너리와 리스트를 조합한 성적 관리 시스템

**다음 장에서는:**

`if`, `for`, `while` 같은 제어문을 배워서 프로그램의 흐름을 제어하고, 조건에 따라 다른 동작을 수행하며, 반복 작업을 자동화하는 방법을 학습합니다. 이것으로 프로그램이 진짜 '지능적'으로 작동하기 시작합니다.