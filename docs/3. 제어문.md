
# 3. 제어문

---

## 3.1 프로그램의 흐름 제어

지금까지 작성한 코드는 위에서 아래로 순서대로 실행되었습니다. 첫 번째 줄이 실행되고, 두 번째 줄이 실행되고, 마지막 줄까지 일직선으로 진행됩니다.

```python
name = "Alice"
age = 20
print(f"{name}은 {age}살입니다")
```

이런 순차 실행만으로는 현실의 복잡한 문제를 해결할 수 없습니다. 프로그램이 상황에 따라 다르게 반응하고, 같은 작업을 여러 번 반복하려면 **흐름 제어(control flow)**가 필요합니다.

예를 들어 성인 인증 시스템을 만든다면:

- 나이가 18세 이상이면 "접근 허용" 출력
- 18세 미만이면 "접근 거부" 출력

또는 1부터 100까지 숫자를 출력한다면:

- `print(1)`, `print(2)`, ... `print(100)`을 100번 타이핑할 수는 없습니다.

제어문은 크게 두 가지로 나뉩니다.

1. **조건문(conditional statement):** 조건에 따라 다른 코드를 실행 (`if`, `elif`, `else`)
2. **반복문(loop):** 같은 코드를 여러 번 실행 (`for`, `while`)

이 장을 마치면 프로그램이 단순 계산기에서 '판단하고 반복하는' 지능적인 도구로 변합니다.

---

## 3.2 조건문 (if, elif, else)

### 3.2.1 if 문의 기본 구조

`if` 문은 조건이 참일 때만 특정 코드를 실행합니다.

```python
age = 20

if age >= 18:
    print("성인입니다")
    print("투표 가능합니다")
```

출력:

```
성인입니다
투표 가능합니다
```

**문법 구조:**

```python
if 조건식:
    실행할 코드
    실행할 코드
```

**핵심 요소:**

1. **조건식:** `age >= 18` 같은 비교 연산. 결과는 `True` 또는 `False`
2. **콜론(`:`):** 조건식 끝에 반드시 붙여야 함
3. **들여쓰기:** 조건이 참일 때 실행할 코드는 반드시 **들여쓰기** (스페이스 4칸)

들여쓰기가 끝나면 if 블록이 종료됩니다.

```python
age = 15

if age >= 18:
    print("성인입니다")

print("프로그램 종료")   # 조건과 무관하게 항상 실행
```

출력:

```
프로그램 종료
```

`age`가 15이므로 조건이 거짓이어서 "성인입니다"는 출력되지 않지만, "프로그램 종료"는 if 블록 밖에 있으므로 실행됩니다.

### 3.2.2 if-else 문

조건이 거짓일 때 실행할 코드를 지정하려면 `else`를 사용합니다.

```python
age = 15

if age >= 18:
    print("성인입니다")
else:
    print("미성년자입니다")
```

출력:

```
미성년자입니다
```

**실습 예제: 짝수/홀수 판별**

```python
number = int(input("숫자를 입력하세요: "))

if number % 2 == 0:
    print(f"{number}는 짝수입니다")
else:
    print(f"{number}는 홀수입니다")
```

실행 예시:

```
숫자를 입력하세요: 7
7는 홀수입니다
```

### 3.2.3 if-elif-else 문

두 가지 이상의 경우를 처리하려면 `elif` (else if의 줄임말)를 사용합니다.

```python
score = 85

if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
elif score >= 60:
    grade = "D"
else:
    grade = "F"

print(f"점수: {score}, 등급: {grade}")
```

출력:

```
점수: 85, 등급: B
```

**실행 흐름:**

1. `score >= 90`? → 거짓, 다음으로
2. `score >= 80`? → **참**, "B" 할당 후 **전체 if 블록 종료**
3. 나머지 elif와 else는 검사하지 않음

**순서가 중요합니다:**

```python
# 잘못된 예
score = 85

if score >= 60:      # 85는 60 이상이므로 여기서 True
    grade = "D"
elif score >= 80:    # 이 줄은 실행되지 않음
    grade = "B"
```

조건은 위에서 아래로 검사되며, 첫 번째로 참인 조건만 실행되므로 **높은 점수부터 검사**해야 합니다.

**실습 예제: 성적 등급 부여 (개선)**

```python
score = int(input("점수를 입력하세요 (0-100): "))

if score < 0 or score > 100:
    print("유효하지 않은 점수입니다")
elif score >= 90:
    print("A 등급")
elif score >= 80:
    print("B 등급")
elif score >= 70:
    print("C 등급")
elif score >= 60:
    print("D 등급")
else:
    print("F 등급")
```

### 3.2.4 중첩 조건문

if 문 안에 또 다른 if 문을 넣을 수 있습니다.

```python
age = 20
has_license = True

if age >= 18:
    if has_license:
        print("운전 가능합니다")
    else:
        print("면허를 먼저 취득하세요")
else:
    print("성인이 될 때까지 기다리세요")
```

출력:

```
운전 가능합니다
```

**가독성 주의:**

중첩이 깊어지면 코드가 복잡해집니다. 가능하면 논리 연산자로 단순화하세요.

```python
# 중첩 버전
if age >= 18:
    if has_license:
        print("운전 가능합니다")

# 개선 버전
if age >= 18 and has_license:
    print("운전 가능합니다")
```

### 3.2.5 조건식 심화

**복합 조건: and, or, not**

```python
temperature = 25
is_sunny = True

if temperature >= 20 and is_sunny:
    print("산책하기 좋은 날씨입니다")
```

```python
day = "토요일"

if day == "토요일" or day == "일요일":
    print("주말입니다")
```

```python
is_raining = False

if not is_raining:
    print("우산이 필요 없습니다")
```

**in 연산자 활용:**

여러 값 중 하나인지 확인할 때 유용합니다.

```python
fruit = "apple"

if fruit in ["apple", "banana", "cherry"]:
    print("이 과일은 목록에 있습니다")
```

```python
username = "admin"

if username not in ["guest", "anonymous"]:
    print("등록된 사용자입니다")
```

**삼항 연산자 (조건 표현식):**

간단한 if-else를 한 줄로 작성할 수 있습니다.

```python
age = 20
status = "성인" if age >= 18 else "미성년자"
print(status)   # 성인
```

문법: `참일_때_값 if 조건 else 거짓일_때_값`

단, 복잡한 조건에는 사용하지 마세요. 가독성이 떨어집니다.

**AI 활용 팁:**

복잡한 조건식을 작성했다면 AI에게 검증을 요청하세요.

"이 조건식이 의도대로 작동하는지 확인해줘"

```python
if (age >= 18 and has_license) or (age >= 16 and has_permit and has_guardian):
    print("운전 가능")
```

AI가 조건을 해석하고, 예상치 못한 경우를 지적해줄 수 있습니다.

---

## 3.3 for 반복문

### 3.3.1 for 문의 기본 구조

`for` 문은 시퀀스(리스트, 문자열, 튜플 등)의 각 요소를 순회하며 코드를 반복 실행합니다.

**리스트 순회:**

```python
fruits = ["apple", "banana", "cherry"]

for fruit in fruits:
    print(fruit)
```

출력:

```
apple
banana
cherry
```

**문법 구조:**

```python
for 변수 in 반복_가능한_객체:
    실행할 코드
```

- `fruit`: 반복 변수. 매 반복마다 리스트의 다음 요소를 가리킴
- `fruits`: 반복할 대상
- 들여쓰기: 반복할 코드 블록

**문자열 순회:**

문자열도 반복 가능한 객체입니다.

```python
word = "Python"

for char in word:
    print(char)
```

출력:

```
P
y
t
h
o
n
```

**실습: 리스트 합계 계산**

```python
numbers = [10, 20, 30, 40, 50]
total = 0

for num in numbers:
    total = total + num

print(f"합계: {total}")   # 합계: 150
```

### 3.3.2 range() 함수

특정 횟수만큼 반복하려면 `range()` 함수를 사용합니다.

**`range(n)`: 0부터 n-1까지**

```python
for i in range(5):
    print(i)
```

출력:

```
0
1
2
3
4
```

**`range(start, end)`: 시작과 끝 지정**

```python
for i in range(2, 6):
    print(i)
```

출력:

```
2
3
4
5
```

끝 값은 포함되지 않습니다.

**`range(start, end, step)`: 간격 지정**

```python
for i in range(0, 10, 2):   # 0부터 10 미만까지 2씩 증가
    print(i)
```

출력:

```
0
2
4
6
8
```

**역순 반복:**

```python
for i in range(5, 0, -1):   # 5부터 1까지 1씩 감소
    print(i)
```

출력:

```
5
4
3
2
1
```

**실습: 구구단 2단**

```python
dan = 2

for i in range(1, 10):
    print(f"{dan} × {i} = {dan * i}")
```

출력:

```
2 × 1 = 2
2 × 2 = 4
...
2 × 9 = 18
```

### 3.3.3 enumerate()와 zip()

**`enumerate()`: 인덱스와 값 동시에**

리스트를 순회하면서 인덱스도 필요할 때가 있습니다.

```python
fruits = ["apple", "banana", "cherry"]

for i in range(len(fruits)):
    print(f"{i}: {fruits[i]}")
```

`enumerate()`를 사용하면 더 간결합니다. `enumerate()`는 반복 가능한 객체를 순회할 때 각 항목에 자동으로 순번을 부여하여 (인덱스, 값) 쌍으로 돌려주는 내장 함수입니다. 예를 들어 아래 코드에서 `fruits` 리스트의 각 항목은 `(0, 'apple')`, `(1, 'banana')`처럼 순번과 함께 묶여 `index`와 `fruit`에 차례로 전달됩니다.

```python
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
```

출력:

```
0: apple
1: banana
2: cherry
```

시작 인덱스 변경:

```python
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}: {fruit}")
```

출력:

```
1: apple
2: banana
3: cherry
```

**`zip()`: 여러 리스트 동시 순회**

두 개 이상의 리스트를 동시에 순회합니다. 아래 코드에서 `zip()`은 `names`와 `scores`를 같은 위치끼리 묶어 `('Alice', 85)`, `('Bob', 92)`, `('Charlie', 78)`처럼 쌍으로 만들어주며, `for` 문은 이 쌍을 `name`과 `score`로 나눠 받아 순서대로 처리합니다.

```python
names = ["Alice", "Bob", "Charlie"]
scores = [85, 92, 78]

for name, score in zip(names, scores):
    print(f"{name}: {score}점")
```

출력:

```
Alice: 85점
Bob: 92점
Charlie: 78점
```

길이가 다른 리스트를 zip하면 짧은 쪽에 맞춰집니다.

```python
list1 = [1, 2, 3]
list2 = ['a', 'b']

for num, char in zip(list1, list2):
    print(num, char)
```

출력:

```
1 a
2 b
```

**실습 예제: 학생 이름과 점수 매칭**

```python
students = ["Alice", "Bob", "Charlie", "Diana"]
scores = [85, 92, 78, 95]

print("성적표:")
for rank, (name, score) in enumerate(zip(students, scores), start=1):
    print(f"{rank}번: {name} - {score}점")
```

`zip(students, scores)`로 이름과 점수를 쌍으로 묶고, `enumerate(..., start=1)`로 1부터 시작하는 순번을 추가합니다. `for`문에서 `rank`는 순번, `(name, score)`는 각 쌍을 언패킹하여 받으므로, 결과적으로 순번·이름·점수를 한 번에 순회할 수 있습니다.

출력:

```
성적표:
1번: Alice - 85점
2번: Bob - 92점
3번: Charlie - 78점
4번: Diana - 95점
```

### 3.3.4 딕셔너리 순회

**키만 순회:**

```python
student = {"name": "Alice", "age": 20, "major": "CS"}

for key in student:
    print(key)
```

또는 명시적으로:

```python
for key in student.keys():
    print(key)
```

출력:

```
name
age
major
```

**값만 순회:**

```python
for value in student.values():
    print(value)
```

출력:

```
Alice
20
CS
```

**키-값 쌍 순회:**

```python
for key, value in student.items():
    print(f"{key}: {value}")
```

출력:

```
name: Alice
age: 20
major: CS
```

**실습: 학생 성적 딕셔너리 처리**

```python
grades = {
    "Alice": 85,
    "Bob": 92,
    "Charlie": 78,
    "Diana": 95
}

total = 0
count = 0

for name, score in grades.items():
    print(f"{name}: {score}점")
    total += score
    count += 1

average = total / count
print(f"\n평균: {average:.2f}점")
```

출력:

```
Alice: 85점
Bob: 92점
Charlie: 78점
Diana: 95점

평균: 87.50점
```

### 3.3.5 리스트 컴프리헨션

리스트 컴프리헨션(list comprehension)은 리스트를 간결하게 생성하는 방법입니다.

**기본 형태:**

```python
# 일반적인 방법
squares = []
for i in range(1, 6):
    squares.append(i ** 2)

print(squares)   # [1, 4, 9, 16, 25]
```

`range(1, 6)`으로 1부터 5까지 순회하면서 각 값을 제곱한 결과를 리스트로 만듭니다. `for` 문과 `append()`를 따로 쓰는 대신, 리스트 컴프리헨션은 `[표현식 for 변수 in 반복대상]` 형태로 생성과 변환을 한 줄에 표현합니다.

```python
# 리스트 컴프리헨션
squares = [i ** 2 for i in range(1, 6)]
print(squares)   # [1, 4, 9, 16, 25]
```

**조건 필터링:**

`range(1, 11)`을 순회하면서 `i % 2 == 0` 조건을 만족하는 값, 즉 짝수만 골라 리스트로 만듭니다. 리스트 컴프리헨션에 `if` 조건을 추가하면 필터링과 수집을 한 줄에 처리할 수 있습니다.

```python
# 1~10 중 짝수만
evens = [i for i in range(1, 11) if i % 2 == 0]
print(evens)   # [2, 4, 6, 8, 10]
```

`words` 리스트를 순회하면서 `len(word) >= 5` 조건을 만족하는 단어, 즉 글자 수가 5 이상인 항목만 골라 새 리스트로 만듭니다.

```python
# 문자열 리스트에서 길이 5 이상만
words = ["apple", "bat", "cherry", "date", "elephant"]
long_words = [word for word in words if len(word) >= 5]
print(long_words)   # ['apple', 'cherry', 'elephant']
```

**if-else 포함:**

`range(5)`를 순회하면서 각 값이 짝수이면 `'even'`, 홀수이면 `'odd'`를 할당합니다. 표현식 자리에 `if ... else ...` 형태의 삼항 조건식을 넣어 값 변환과 분기를 한 줄에 처리합니다.

```python
# 짝수는 "even", 홀수는 "odd"
labels = ["even" if i % 2 == 0 else "odd" for i in range(5)]
print(labels)   # ['even', 'odd', 'even', 'odd', 'even']
```

**중첩 컴프리헨션:**

2차원 리스트 `matrix`를 첫 번째 `for`인 `for row in matrix`로 행을 순회하고, 두 번째 `for`인 `for num in row`로 각 행의 요소를 꺼냅니다. 예를 들어 `row = [1, 2, 3]`이면 `1`, `2`, `3`을, `row = [4, 5, 6]`이면 `4`, `5`, `6`을 차례로 수집하고, 이 과정이 마지막 행까지 이어져 결국 `[1, 2, 3, 4, 5, 6, 7, 8, 9]`가 만들어집니다. 중첩된 `for` 문을 리스트 컴프리헨션 안에 순서대로 나열하면 이처럼 중첩 구조를 한 줄에 평탄화할 수 있습니다.

```python
# 2차원 리스트 평탄화
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row]
print(flat)   # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

위 리스트 컴프리헨션은 다음 중첩 `for` 문과 동일하게 동작합니다. 실무에서는 중첩 `for` 문을 더 많이 씁니다. 중첩 컴프리헨션은 한 줄로 간결하지만 가독성이 떨어져, 팀 코드나 복잡한 로직에서는 오히려 이해하기 어렵습니다. 파이썬 커뮤니티에서도 가독성을 우선하는 경향이 있어, 중첩이 생기는 순간 `for` 문으로 풀어 쓰는 것을 권장하는 편입니다.

```python
# 중첩 for 문으로 2차원 리스트를 1차원으로 평탄화
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = []
for row in matrix:
    for num in row:
        flat.append(num)
print(flat)   # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**가독성 주의:**

리스트 컴프리헨션은 강력하지만, 너무 복잡하면 오히려 가독성이 떨어집니다.

```python
# 나쁜 예 (복잡함)
result = [x*y for x in range(10) if x % 2 == 0 for y in range(10) if y % 3 == 0]

# 좋은 예 (명확함)
result = []
for x in range(10):
    if x % 2 == 0:
        for y in range(10):
            if y % 3 == 0:
                result.append(x * y)
```

기준: 한 줄이 **80자를 넘거나**, 조건이 **2개 이상 중첩**되면 일반 for 문을 사용하세요.

---

## 3.4 while 반복문

### 3.4.1 while 문의 기본 구조

`while` 문은 조건이 참인 동안 코드를 반복 실행합니다.

```python
count = 0

while count < 5:
    print(f"카운트: {count}")
    count += 1
```

출력:

```
카운트: 0
카운트: 1
카운트: 2
카운트: 3
카운트: 4
```

**문법 구조:**

```python
while 조건:
    실행할 코드
    조건을 변경하는 코드  # 중요!
```

조건을 변경하지 않으면 **무한 루프**에 빠집니다.

```python
# 무한 루프 (절대 종료되지 않음)
count = 0
while count < 5:
    print(count)
    # count를 증가시키지 않음!
```

**for vs while 선택:**

- 반복 횟수를 알 때: `for`
- 조건에 따라 반복할 때: `while`

```python
# for가 적합: 정확히 10번
for i in range(10):
    print(i)

# while이 적합: 사용자가 'quit' 입력할 때까지
while True:
    command = input("명령을 입력하세요: ")
    if command == "quit":
        break
```

### 3.4.2 무한 루프와 탈출

**의도적 무한 루프: `while True`**

종료 조건을 내부에서 처리하는 패턴입니다.

```python
while True:
    user_input = input("숫자를 입력하세요 (종료: q): ")
    
    if user_input == 'q':
        print("프로그램 종료")
        break
    
    number = int(user_input)
    print(f"입력한 숫자: {number}")
```

**`break`: 반복 중단**

`break`를 만나면 즉시 반복문을 빠져나갑니다.

```python
numbers = [1, 3, 5, 7, 8, 10, 12]

for num in numbers:
    if num % 2 == 0:
        print(f"첫 번째 짝수: {num}")
        break
```

출력:

```
첫 번째 짝수: 8
```

**`continue`: 다음 반복으로**

`continue`를 만나면 현재 반복을 건너뛰고 다음 반복으로 넘어갑니다.

```python
for i in range(1, 6):
    if i == 3:
        continue
    print(i)
```

출력:

```
1
2
4
5
```

3일 때 `continue`를 만나서 `print(i)`를 실행하지 않고 다음 반복으로 넘어갔습니다.

### 3.4.3 플래그 변수 활용

반복 종료 조건을 관리하기 위해 불린 변수를 사용하는 패턴입니다.

```python
found = False
numbers = [3, 7, 12, 5, 18]
target = 12

for num in numbers:
    if num == target:
        found = True
        break

if found:
    print(f"{target}을 찾았습니다")
else:
    print(f"{target}을 찾지 못했습니다")
```

출력:

```
12을 찾았습니다
```

**실습 예제: 사용자 입력 반복 받기**

```python
total = 0
count = 0

print("숫자를 입력하세요 (종료: 0)")

while True:
    user_input = input("숫자: ")
    
    number = int(user_input)
    
    if number == 0:
        break
    
    total += number
    count += 1

if count > 0:
    average = total / count
    print(f"\n입력한 숫자 개수: {count}")
    print(f"합계: {total}")
    print(f"평균: {average:.2f}")
else:
    print("입력한 숫자가 없습니다")
```

---

## 3.5 반복 제어: break, continue, pass

### 3.5.1 break

**반복문 즉시 종료**

앞에서 본 것처럼 `break`는 반복문을 완전히 빠져나갑니다.

**중첩 반복문에서의 break:**

`break`는 **가장 가까운** 반복문만 종료합니다.

```python
for i in range(3):
    for j in range(3):
        if j == 1:
            break
        print(f"i={i}, j={j}")
    print(f"i={i} 바깥 루프")
```

출력:

```
i=0, j=0
i=0 바깥 루프
i=1, j=0
i=1 바깥 루프
i=2, j=0
i=2 바깥 루프
```

내부 for 문만 break되고, 외부 for 문은 계속 실행됩니다.

**실습: 특정 값 찾으면 종료**

```python
students = [
    {"name": "Alice", "score": 85},
    {"name": "Bob", "score": 92},
    {"name": "Charlie", "score": 78},
    {"name": "Diana", "score": 95}
]

target_name = "Charlie"

for student in students:
    if student["name"] == target_name:
        print(f"{target_name}의 점수: {student['score']}")
        break
```

출력:

```
Charlie의 점수: 78
```

### 3.5.2 continue

**현재 반복만 건너뛰기**

홀수만 출력 (짝수는 건너뛰기):

```python
for i in range(1, 11):
    if i % 2 == 0:
        continue
    print(i)
```

출력:

```
1
3
5
7
9
```

**조건 필터링에 활용:**

```python
scores = [85, -1, 92, 78, -1, 95]

valid_scores = []

for score in scores:
    if score == -1:   # 유효하지 않은 데이터
        continue
    valid_scores.append(score)

print(valid_scores)   # [85, 92, 78, 95]
```

### 3.5.3 pass

`pass`는 **아무 동작도 하지 않는** 키워드입니다. 문법적으로 코드가 필요하지만 아직 구현하지 않았을 때 사용합니다.

```python
for i in range(5):
    if i == 2:
        pass   # 나중에 구현 예정
    else:
        print(i)
```

출력:

```
0
1
3
4
```

주로 코드 구조를 잡을 때 사용합니다.

```python
def process_data(data):
    pass   # TODO: 나중에 구현

def analyze_results(results):
    pass   # TODO: 나중에 구현
```

### 3.5.4 else 절

`for`와 `while` 문에 `else`를 붙일 수 있습니다. **break 없이 정상 종료**되었을 때만 실행됩니다.

```python
numbers = [1, 3, 5, 7, 9]

for num in numbers:
    if num % 2 == 0:
        print("짝수를 찾았습니다")
        break
else:
    print("짝수가 없습니다")
```

출력:

```
짝수가 없습니다
```

break가 실행되지 않았으므로 else 블록이 실행되었습니다.

```python
numbers = [1, 3, 5, 8, 9]

for num in numbers:
    if num % 2 == 0:
        print("짝수를 찾았습니다")
        break
else:
    print("짝수가 없습니다")
```

출력:

```
짝수를 찾았습니다
```

break가 실행되었으므로 else는 실행되지 않습니다.

---

## 3.6 중첩 반복문

### 3.6.1 반복문 안의 반복문

반복문 안에 또 다른 반복문을 넣을 수 있습니다.

**구구단 전체 출력:**

```python
for dan in range(2, 10):
    print(f"\n{dan}단:")
    for i in range(1, 10):
        print(f"{dan} × {i} = {dan * i}")
```

출력:

```
2단:
2 × 1 = 2
2 × 2 = 4
...
9 × 9 = 81
```

**2차원 리스트 처리:**

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for row in matrix:
    for element in row:
        print(element, end=" ")
    print()   # 줄바꿈
```

출력:

```
1 2 3 
4 5 6 
7 8 9 
```

**패턴 출력:**

```python
for i in range(1, 6):
    for j in range(i):
        print("*", end="")
    print()
```

출력:

```
*
**
***
****
*****
```

### 3.6.2 성능 고려사항

중첩 깊이가 깊어질수록 실행 시간이 기하급수적으로 증가합니다.

```python
# 2중 반복: 100 * 100 = 10,000회
for i in range(100):
    for j in range(100):
        pass

# 3중 반복: 100 * 100 * 100 = 1,000,000회
for i in range(100):
    for j in range(100):
        for k in range(100):
            pass
```

**최적화 팁:**

1. 불필요한 중첩 피하기
2. 가능하면 내부 반복 횟수 줄이기
3. 조건을 먼저 검사해서 불필요한 반복 방지

```python
# 비효율적
for i in range(1000):
    for j in range(1000):
        if some_condition:   # 매번 검사
            process()

# 개선
if some_condition:   # 한 번만 검사
    for i in range(1000):
        for j in range(1000):
            process()
```

---

## 3.7 실습: 데이터 필터링과 집계

### 3.7.1 요구사항

학생 성적 데이터에서 조건에 맞는 학생을 추출하고 통계를 계산하는 프로그램을 만들어봅시다.

- 전체 학생 목록과 과목별 점수
- 특정 점수 이상 학생만 추출
- 과목별 평균 계산
- 전체 평균이 가장 높은 학생 찾기

### 3.7.2 코드 작성

`grade_analysis.py` 파일을 만들고 다음 코드를 작성합니다.

```python
# 학생 성적 데이터
students = {
    "Alice": {"math": 85, "english": 92, "science": 78},
    "Bob": {"math": 92, "english": 88, "science": 95},
    "Charlie": {"math": 78, "english": 85, "science": 80},
    "Diana": {"math": 95, "english": 98, "science": 96},
    "Eve": {"math": 70, "english": 75, "science": 72}
}

print("=" * 60)
print("학생 성적 분석 시스템")
print("=" * 60)

# 1. 전체 학생의 평균 계산
print("\n1. 전체 학생 평균:")
student_averages = {}

for name, scores in students.items():
    total = 0
    count = 0
    
    for subject, score in scores.items():
        total += score
        count += 1
    
    average = total / count
    student_averages[name] = average
    print(f"  {name}: {average:.2f}점")

# 2. 평균 80점 이상 학생만 추출
print("\n2. 평균 80점 이상 우수 학생:")
excellent_students = []

for name, average in student_averages.items():
    if average >= 80:
        excellent_students.append(name)
        print(f"  {name}: {average:.2f}점")

# 3. 과목별 평균 계산
print("\n3. 과목별 평균:")
subject_totals = {"math": 0, "english": 0, "science": 0}
student_count = len(students)

for name, scores in students.items():
    for subject, score in scores.items():
        subject_totals[subject] += score

for subject, total in subject_totals.items():
    average = total / student_count
    print(f"  {subject.capitalize()}: {average:.2f}점")

# 4. 최고 평균 학생 찾기
print("\n4. 최고 평균 학생:")
max_average = 0
top_student = ""

for name, average in student_averages.items():
    if average > max_average:
        max_average = average
        top_student = name

print(f"  {top_student}: {max_average:.2f}점")

# 5. 특정 과목(수학) 90점 이상 학생
print("\n5. 수학 90점 이상 학생:")
for name, scores in students.items():
    if scores["math"] >= 90:
        print(f"  {name}: {scores['math']}점")

print("\n" + "=" * 60)
```

실행 결과:

```
============================================================
학생 성적 분석 시스템
============================================================

1. 전체 학생 평균:
  Alice: 85.00점
  Bob: 91.67점
  Charlie: 81.00점
  Diana: 96.33점
  Eve: 72.33점

2. 평균 80점 이상 우수 학생:
  Alice: 85.00점
  Bob: 91.67점
  Charlie: 81.00점
  Diana: 96.33점

3. 과목별 평균:
  Math: 84.00점
  English: 87.60점
  Science: 84.20점

4. 최고 평균 학생:
  Diana: 96.33점

5. 수학 90점 이상 학생:
  Bob: 92점
  Diana: 95점

============================================================
```

**코드 설명:**

1. **중첩 딕셔너리 순회:** `students.items()`로 이름과 성적 딕셔너리를 가져오고, 다시 `scores.items()`로 과목과 점수를 순회
2. **조건 필터링:** `if average >= 80`으로 우수 학생만 추출
3. **집계 변수:** `subject_totals` 딕셔너리에 과목별 합계를 누적
4. **최댓값 찾기:** `max_average` 변수를 계속 갱신하며 최고 평균 학생 추적

### 3.7.3 디버깅 실습

이 코드에 의도적으로 버그를 넣어 디버깅 연습을 해봅시다.

**버그가 있는 코드:**

```python
# 학생 성적 데이터
students = {
    "Alice": {"math": 85, "english": 92, "science": 78},
    "Bob": {"math": 92, "english": 88, "science": 95},
    "Charlie": {"math": 78, "english": 85, "science": 80},
    "Diana": {"math": 95, "english": 98, "science": 96},
    "Eve": {"math": 70, "english": 75, "science": 72}
}

# 과목별 평균 계산 (버그 있음)
subject_totals = {"math": 0, "english": 0, "science": 0}
student_count = len(students)

for name, scores in students.items():
    for subject, score in scores.items():
        subject_totals[subject] = score   # += 대신 =

for subject, total in subject_totals.items():
    average = total / student_count
    print(f"  {subject.capitalize()}: {average:.2f}점")
```

**디버거로 찾기:**

1. `subject_totals[subject] = score` 줄에 Breakpoint 설정
2. F5로 디버그 실행
3. Variables 패널에서 `subject_totals` 값 관찰
4. Step Over (F10)로 반복하며 값이 누적되지 않고 덮어써지는 것 확인
5. `=`를 `+=`로 수정

**AI 활용 팁:**

논리 오류를 찾기 어려울 때 AI에게 물어보세요.

"이 코드에서 과목별 평균이 잘못 계산됩니다. 어디가 문제인가요?"

```python
for name, scores in students.items():
    for subject, score in scores.items():
        subject_totals[subject] = score
```

AI가 "누적이 아니라 덮어쓰기를 하고 있습니다. `=`를 `+=`로 변경하세요"라고 알려줄 것입니다.

---

**이 장에서 배운 것:**

- **조건문:** `if`, `elif`, `else`로 조건에 따라 다른 코드 실행
- **for 반복문:** 리스트, 문자열, 딕셔너리 순회, `range()`, `enumerate()`, `zip()` 활용
- **리스트 컴프리헨션:** 간결한 리스트 생성과 필터링
- **while 반복문:** 조건 기반 반복, 무한 루프와 탈출
- **반복 제어:** `break`, `continue`, `pass`, `else` 절
- **중첩 반복문:** 2차원 데이터 처리, 성능 고려
- **실습:** 조건문과 반복문을 결합한 데이터 분석 프로그램
- **디버깅:** VS Code 디버거로 변수 추적

**다음 장에서는:**

함수(function)를 배워서 코드를 재사용 가능한 단위로 나누고, 복잡한 프로그램을 체계적으로 구성하는 방법을 학습합니다. 함수는 프로그래밍의 핵심 개념이며, 앞으로 모든 코드 작성의 기본이 됩니다.