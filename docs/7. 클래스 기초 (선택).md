
# 7. 클래스 기초 (선택)

---

## 7.1 클래스가 필요한 이유

지금까지 배운 방식으로 학생 정보를 관리한다면 어떻게 될까요?

```python
# 방법 1: 개별 변수
student1_name = "Alice"
student1_age = 20
student1_scores = [85, 92, 78]

student2_name = "Bob"
student2_age = 21
student2_scores = [92, 88, 95]

# 방법 2: 딕셔너리
student1 = {"name": "Alice", "age": 20, "scores": [85, 92, 78]}
student2 = {"name": "Bob", "age": 21, "scores": [92, 88, 95]}

# 평균 계산
def get_average(student):
    scores = student["scores"]
    return sum(scores) / len(scores)
```

딕셔너리 방식은 꽤 쓸 만합니다. 하지만 세 가지 문제가 남아 있습니다.

첫째, **데이터와 기능이 분리**되어 있습니다. `student1`이라는 데이터와 `get_average()`라는 기능이 따로 존재합니다. 학생에 관한 것들이 코드 여기저기 흩어져 있습니다.

둘째, **잘못된 데이터를 막을 방법이 없습니다.** 누군가 `student1["age"] = -5`를 써도 아무도 막지 않습니다.

셋째, **학생이 '할 수 있는 일'이 명확하지 않습니다.** 어떤 함수가 이 학생 데이터와 관련 있는지 파악하려면 코드 전체를 뒤져야 합니다.

**클래스(class)**는 이 세 문제를 한 번에 해결합니다. 데이터(속성)와 기능(메서드)을 하나의 단위로 묶어서, 관련된 모든 것을 한 곳에 모아둡니다.

**실생활 비유: 설계도와 실체**

클래스는 **설계도**입니다. 스마트폰 설계도가 있으면, 그 설계도로 수많은 스마트폰을 만들 수 있습니다. 각 스마트폰은 같은 구조를 가지지만(화면, 카메라, 배터리), 저장된 사진이나 연락처는 제각각입니다.

- **클래스(class):** 스마트폰 설계도
- **인스턴스(instance):** 설계도로 만들어진 실제 스마트폰
- **속성(attribute):** 스마트폰의 특성 (화면 크기, 저장된 사진)
- **메서드(method):** 스마트폰이 할 수 있는 일 (전화 걸기, 사진 찍기)

**데이터 분석에서 클래스를 마주치는 순간:**

사실 우리는 이미 클래스를 계속 사용해왔습니다.

```python
import pandas as pd

df = pd.DataFrame({"a": [1, 2, 3]})   # DataFrame 클래스의 인스턴스 생성
df.head()                               # 메서드 호출
df.shape                                # 속성 접근

from sklearn.linear_model import LinearRegression
model = LinearRegression()              # 클래스 인스턴스 생성
model.fit(X, y)                         # 메서드 호출
model.coef_                             # 속성 접근
```

`df`는 `DataFrame` 클래스의 인스턴스이고, `model`은 `LinearRegression` 클래스의 인스턴스입니다. 클래스를 이해하면 이런 라이브러리의 구조가 자연스럽게 읽힙니다.

---

## 7.2 클래스 기본 구조

### 7.2.1 클래스 정의

`class` 키워드로 클래스를 정의합니다.

```python
class Student:
    pass
```

**클래스 이름 규칙:**

- 첫 글자는 대문자 (PascalCase, UpperCamelCase)
- 여러 단어라면 각 단어의 첫 글자를 대문자로
- `Student`, `DataAnalyzer`, `GradeReport` 등

함수는 `calculate_average` (소문자 + 밑줄), 클래스는 `Student` (대문자 시작)입니다. 이름만 봐도 클래스인지 함수인지 알 수 있습니다.

**가장 단순한 클래스:**

```python
class Student:
    pass

# 인스턴스 생성
alice = Student()
print(type(alice))   # <class '__main__.Student'>
```

### 7.2.2 `__init__` 메서드

클래스를 생성할 때 초기 데이터를 설정하는 메서드입니다. 인스턴스가 만들어지는 순간 자동으로 호출됩니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

**`self`의 의미:**

`self`는 '나 자신'을 가리킵니다. 인스턴스가 자기 자신의 속성을 설정하거나 메서드를 호출할 때 사용합니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name    # self.name: 이 인스턴스의 name 속성
        self.age = age      # self.age: 이 인스턴스의 age 속성
```

`self`는 관례적인 이름입니다. 기술적으로 다른 이름을 써도 되지만, 모든 Python 코드에서 `self`를 사용하는 것이 강력한 관례입니다.

**인스턴스 속성 정의:**

`self.속성명 = 값` 형태로 인스턴스 속성을 만듭니다.

```python
class Student:
    def __init__(self, name, age, scores=None):
        self.name = name
        self.age = age
        self.scores = scores if scores is not None else []
```

기본값으로 빈 리스트를 주고 싶을 때, `scores=[]`는 위험합니다. 모든 인스턴스가 같은 리스트 객체를 공유하게 됩니다. `None`으로 받고 내부에서 새 리스트를 만드는 것이 올바른 방법입니다.

### 7.2.3 인스턴스 생성

클래스를 함수처럼 호출하면 인스턴스가 만들어집니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

alice = Student("Alice", 20)
bob = Student("Bob", 21)

print(alice.name)   # Alice
print(bob.age)      # 21
```

**여러 인스턴스의 독립성:**

각 인스턴스는 자신만의 속성을 가집니다.

```python
alice = Student("Alice", 20)
bob = Student("Bob", 21)

alice.age = 25   # alice의 age만 바뀜

print(alice.age)  # 25
print(bob.age)    # 21 (변하지 않음)
```

### 7.2.4 메서드 정의

클래스 안에서 정의하는 함수를 **메서드(method)**라고 합니다. 첫 번째 매개변수는 항상 `self`입니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.scores = []
    
    def add_score(self, score):
        """점수 추가"""
        self.scores.append(score)
    
    def get_average(self):
        """평균 점수 반환"""
        if not self.scores:
            return 0
        return sum(self.scores) / len(self.scores)
    
    def introduce(self):
        """자기소개"""
        avg = self.get_average()
        print(f"이름: {self.name}, 나이: {self.age}, 평균: {avg:.1f}")

# 사용
alice = Student("Alice", 20)
alice.add_score(85)
alice.add_score(92)
alice.add_score(78)

alice.introduce()
print(alice.get_average())
```

출력:

```
이름: Alice, 나이: 20, 평균: 85.0
85.0
```

메서드를 호출할 때는 `self`를 직접 넣지 않아도 됩니다. Python이 자동으로 인스턴스를 첫 번째 인자로 전달합니다.

---

## 7.3 클래스 속성과 메서드

### 7.3.1 인스턴스 속성 vs 클래스 속성

**인스턴스 속성:** 각 인스턴스마다 독립적으로 존재합니다.

```python
class Student:
    def __init__(self, name):
        self.name = name   # 인스턴스 속성
```

**클래스 속성:** 모든 인스턴스가 공유합니다. 클래스 정의 내부, 메서드 밖에 선언합니다.

```python
class Student:
    school = "파이썬 고등학교"   # 클래스 속성
    count = 0                    # 학생 수 추적
    
    def __init__(self, name):
        self.name = name         # 인스턴스 속성
        Student.count += 1       # 클래스 속성 수정

alice = Student("Alice")
bob = Student("Bob")

print(alice.school)    # 파이썬 고등학교
print(bob.school)      # 파이썬 고등학교
print(Student.school)  # 파이썬 고등학교 (클래스로 직접 접근)

print(Student.count)   # 2
```

**클래스 속성을 인스턴스로 수정하면:**

```python
alice.school = "다른 학교"  # alice만의 school 속성이 새로 만들어짐

print(alice.school)     # 다른 학교
print(bob.school)       # 파이썬 고등학교 (영향 없음)
print(Student.school)   # 파이썬 고등학교 (영향 없음)
```

### 7.3.2 다양한 메서드 종류

**인스턴스 메서드 (가장 일반적):**

첫 번째 인자가 `self`이며, 인스턴스의 속성에 접근합니다.

```python
class Student:
    def get_average(self):   # 인스턴스 메서드
        return sum(self.scores) / len(self.scores)
```

**클래스 메서드 (`@classmethod`):**

첫 번째 인자가 `cls`이며, 클래스 자체에 접근합니다. 인스턴스 없이 호출합니다.

```python
class Student:
    school = "파이썬 고등학교"
    count = 0
    
    def __init__(self, name):
        self.name = name
        Student.count += 1
    
    @classmethod
    def get_count(cls):
        return cls.count
    
    @classmethod
    def from_dict(cls, data):
        """딕셔너리에서 Student 인스턴스 생성"""
        return cls(data['name'])

# 인스턴스 없이 호출
print(Student.get_count())   # 0

alice = Student("Alice")
bob = Student("Bob")
print(Student.get_count())   # 2

# 딕셔너리에서 생성
data = {"name": "Charlie", "age": 19}
charlie = Student.from_dict(data)
print(charlie.name)   # Charlie
```

**정적 메서드 (`@staticmethod`):**

`self`도 `cls`도 받지 않습니다. 클래스와 논리적으로 관련이 있지만, 인스턴스나 클래스 속성에 접근하지 않는 유틸리티 함수입니다.

```python
class Student:
    @staticmethod
    def is_valid_score(score):
        """점수가 유효한 범위인지 확인"""
        return 0 <= score <= 100
    
    def add_score(self, score):
        if Student.is_valid_score(score):
            self.scores.append(score)
        else:
            print(f"유효하지 않은 점수: {score}")

# 인스턴스 없이 호출
print(Student.is_valid_score(85))    # True
print(Student.is_valid_score(150))   # False
```

**언제 무엇을 쓰는가:**

- 인스턴스 속성이 필요하면 → **인스턴스 메서드**
- 클래스 속성만 필요하면 → **클래스 메서드**
- 둘 다 필요 없는 유틸리티 함수면 → **정적 메서드**

### 7.3.3 특수 메서드 (Magic Method)

이중 밑줄로 시작하고 끝나는 메서드들입니다. Python 내부 동작과 연결됩니다.

**`__str__`: 문자열 표현**

`print()`나 `str()`로 출력할 때 사용됩니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        return f"Student({self.name}, {self.age}세)"

alice = Student("Alice", 20)
print(alice)   # Student(Alice, 20세)
print(str(alice))  # Student(Alice, 20세)
```

`__str__`이 없으면 `<__main__.Student object at 0x7f...>` 같은 알 수 없는 주소가 출력됩니다.

**`__repr__`: 개발자용 표현**

디버깅할 때 사용합니다. 가능하면 인스턴스를 재현할 수 있는 형태로 작성합니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        return f"{self.name} ({self.age}세)"
    
    def __repr__(self):
        return f"Student(name='{self.name}', age={self.age})"

alice = Student("Alice", 20)
print(alice)       # Alice (20세) → __str__ 호출
print(repr(alice)) # Student(name='Alice', age=20) → __repr__ 호출
```

**`__len__`: 길이**

`len()`으로 길이를 구할 때 사용됩니다.

```python
class Classroom:
    def __init__(self):
        self.students = []
    
    def add_student(self, student):
        self.students.append(student)
    
    def __len__(self):
        return len(self.students)

classroom = Classroom()
classroom.add_student(Student("Alice", 20))
classroom.add_student(Student("Bob", 21))

print(len(classroom))   # 2
```

**`__eq__`: 동등 비교**

`==` 연산자가 호출하는 메서드입니다.

```python
class Student:
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
    
    def __eq__(self, other):
        # 학번이 같으면 같은 학생
        return self.student_id == other.student_id

alice1 = Student("Alice", "S001")
alice2 = Student("Alice Kim", "S001")

print(alice1 == alice2)   # True (학번이 같으므로)
```

---

## 7.4 상속

### 7.4.1 상속의 개념

상속(inheritance)은 기존 클래스의 속성과 메서드를 그대로 물려받아 새 클래스를 만드는 방법입니다.

- **부모 클래스 (Parent class, 슈퍼클래스):** 물려주는 쪽
- **자식 클래스 (Child class, 서브클래스):** 물려받는 쪽

**'is-a' 관계:**

상속은 "A는 B다"라는 관계에서 성립합니다.

- `GraduateStudent`(대학원생)는 `Student`(학생)다 → 상속 적합
- `Classroom`(교실)은 `Student`(학생)다 → 상속 부적합

상속을 너무 많이 쓰면 구조가 복잡해집니다. 'is-a' 관계가 명확할 때만 사용하세요.

### 7.4.2 상속 구현

```python
class Student:
    """기본 학생 클래스"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.scores = []
    
    def add_score(self, score):
        self.scores.append(score)
    
    def get_average(self):
        if not self.scores:
            return 0
        return sum(self.scores) / len(self.scores)
    
    def __str__(self):
        return f"{self.name} (나이: {self.age})"


class GraduateStudent(Student):   # Student를 상속
    """대학원생 클래스"""
    
    def __init__(self, name, age, thesis_topic):
        super().__init__(name, age)   # 부모 __init__ 호출
        self.thesis_topic = thesis_topic   # 추가 속성
    
    def describe_research(self):
        print(f"{self.name}의 논문 주제: {self.thesis_topic}")


# 부모 클래스
alice = Student("Alice", 20)
alice.add_score(85)
print(alice.get_average())   # 85.0

# 자식 클래스
dave = GraduateStudent("Dave", 26, "머신러닝 기반 성적 예측")
dave.add_score(92)           # 부모 메서드 사용 가능
dave.add_score(88)
print(dave.get_average())    # 90.0
dave.describe_research()     # Dave의 논문 주제: 머신러닝 기반 성적 예측
```

**`super()`: 부모 메서드 호출**

자식 클래스에서 부모 클래스의 메서드를 호출합니다.

```python
class GraduateStudent(Student):
    def __init__(self, name, age, thesis_topic):
        super().__init__(name, age)   # Student.__init__ 실행
        self.thesis_topic = thesis_topic
```

`super().__init__`을 호출하지 않으면 부모의 초기화가 실행되지 않아서 `self.scores` 같은 속성이 존재하지 않게 됩니다.

**메서드 오버라이딩:**

부모의 메서드를 자식에서 재정의합니다.

```python
class GraduateStudent(Student):
    def __init__(self, name, age, thesis_topic):
        super().__init__(name, age)
        self.thesis_topic = thesis_topic
    
    def __str__(self):
        # 부모의 __str__을 확장
        base = super().__str__()
        return f"{base} [대학원생, 논문: {self.thesis_topic}]"

dave = GraduateStudent("Dave", 26, "머신러닝")
print(dave)   # Dave (나이: 26) [대학원생, 논문: 머신러닝]
```

### 7.4.3 isinstance()와 issubclass()

**`isinstance()`: 인스턴스의 타입 확인**

```python
alice = Student("Alice", 20)
dave = GraduateStudent("Dave", 26, "머신러닝")

print(isinstance(alice, Student))          # True
print(isinstance(dave, GraduateStudent))   # True
print(isinstance(dave, Student))           # True (상속 관계)
print(isinstance(alice, GraduateStudent))  # False
```

자식 클래스의 인스턴스는 부모 클래스의 인스턴스이기도 합니다.

**`issubclass()`: 클래스 관계 확인**

```python
print(issubclass(GraduateStudent, Student))   # True
print(issubclass(Student, GraduateStudent))   # False
```

**다형성의 기초:**

부모 클래스 타입으로 자식 클래스 인스턴스를 다룰 수 있습니다.

```python
def print_student_info(student):
    """Student 또는 그 자식 클래스의 인스턴스를 처리"""
    print(student)             # __str__ 호출
    print(student.get_average())  # 부모 메서드

alice = Student("Alice", 20)
alice.add_score(85)

dave = GraduateStudent("Dave", 26, "머신러닝")
dave.add_score(92)

print_student_info(alice)   # Student 처리
print_student_info(dave)    # GraduateStudent도 처리 가능
```

**AI 활용 팁:**

클래스 구조를 설계할 때 AI에게 조언을 구하세요.

"온라인 강의 플랫폼을 만들려고 합니다. User, Student, Instructor, Course 클래스가 필요한데 상속 구조를 어떻게 설계하면 좋을까요?"

AI가 'is-a'와 'has-a' 관계를 분석해서 상속 구조를 제안해줄 것입니다.

---

## 7.5 캡슐화

### 7.5.1 접근 제어의 필요성

클래스의 내부 데이터를 외부에서 마음대로 바꿀 수 있으면 문제가 생깁니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

alice = Student("Alice", 20)
alice.age = -5   # 아무도 막지 않음
```

나이가 음수가 되었습니다. 이런 상황을 막으려면 **캡슐화(encapsulation)**가 필요합니다. 내부 데이터는 감추고, 정해진 방법으로만 접근하게 합니다.

### 7.5.2 Python의 접근 제어

Python은 언어 차원에서 강제로 접근을 막지는 않습니다. 대신 **이름 규칙**으로 의도를 표현합니다.

**공개 속성: `name`**

누구나 접근 가능합니다.

```python
class Student:
    def __init__(self, name):
        self.name = name   # 공개 속성
```

**관례적 비공개: `_name`**

하나의 밑줄로 시작하는 속성은 "내부 용도입니다. 가능하면 직접 접근하지 마세요"라는 신호입니다. 기술적으로 막히지는 않지만, 관례를 존중하는 것이 중요합니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self._age = age      # 관례적 비공개

alice = Student("Alice", 20)
print(alice._age)   # 접근은 되지만 권장하지 않음
```

**강제 비공개: `__name` (name mangling)**

두 개의 밑줄로 시작하면 Python이 이름을 변형시켜서 직접 접근을 어렵게 만듭니다.

```python
class Student:
    def __init__(self, name, score):
        self.name = name
        self.__score = score   # 강제 비공개

alice = Student("Alice", 85)
print(alice.__score)   # AttributeError: 'Student' object has no attribute '__score'
```

내부적으로는 `_Student__score`로 이름이 바뀝니다.

```python
print(alice._Student__score)   # 85 (우회 가능, 하지만 쓰지 않는 것이 원칙)
```

### 7.5.3 프로퍼티 (Property)

속성처럼 접근하지만 내부에서 메서드가 실행되는 방식입니다. 유효성 검사나 계산을 투명하게 처리할 수 있습니다.

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self._age = age
    
    @property
    def age(self):
        """나이 getter"""
        return self._age
    
    @age.setter
    def age(self, value):
        """나이 setter: 유효성 검사"""
        if value < 0:
            raise ValueError("나이는 0 이상이어야 합니다")
        if value > 150:
            raise ValueError("나이는 150 이하여야 합니다")
        self._age = value

alice = Student("Alice", 20)

print(alice.age)   # 20 (getter 호출)

alice.age = 21     # setter 호출
print(alice.age)   # 21

alice.age = -5     # ValueError: 나이는 0 이상이어야 합니다
```

**읽기 전용 속성:**

setter 없이 getter만 정의하면 읽기 전용이 됩니다.

```python
class Student:
    def __init__(self, name, scores):
        self.name = name
        self._scores = scores
    
    @property
    def average(self):
        """읽기 전용: 평균 계산"""
        if not self._scores:
            return 0
        return sum(self._scores) / len(self._scores)

alice = Student("Alice", [85, 92, 78])
print(alice.average)   # 85.0

alice.average = 100    # AttributeError: can't set attribute
```

**장점:**

속성을 직접 노출하는 것과 사용법이 같아서, 나중에 내부 구현을 바꿔도 외부 코드를 수정할 필요가 없습니다.

---

## 7.6 데이터 분석에서 클래스 활용

### 7.6.1 scikit-learn API 이해

scikit-learn의 모든 모델은 클래스 기반으로 설계되어 있습니다.

```python
from sklearn.linear_model import LinearRegression

# LinearRegression 클래스의 인스턴스 생성
model = LinearRegression()

# 속성 (인스턴스 속성)
# model.coef_    학습 후 생성됨

# 메서드 호출
model.fit(X_train, y_train)       # 학습 (인스턴스 메서드)
predictions = model.predict(X_test) # 예측
score = model.score(X_test, y_test) # 평가

# 학습 후 생긴 속성
print(model.coef_)     # 가중치
print(model.intercept_) # 절편
```

왜 이런 구조일까요? 모델의 상태(학습된 가중치, 설정값)를 인스턴스 속성으로 관리하면, 여러 모델을 동시에 사용하거나 저장/불러오기가 편리해집니다.

### 7.6.2 Pandas DataFrame 이해

DataFrame은 클래스의 대표적 사례입니다.

```python
import pandas as pd

# DataFrame 클래스의 인스턴스 생성
df = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})

# 속성 (인스턴스 속성)
df.shape        # 형태
df.columns      # 열 이름
df.dtypes       # 데이터 타입

# 메서드 (인스턴스 메서드)
df.head()       # 앞부분 보기
df.describe()   # 통계 요약
df.sort_values('a')   # 정렬

# 메서드 체이닝: 메서드가 DataFrame을 반환하므로 연속 호출 가능
result = (df
          .sort_values('a')
          .reset_index(drop=True)
          .head(2))
```

### 7.6.3 직접 만드는 분석 클래스

반복적인 분석 워크플로우를 클래스로 캡슐화하면 재사용이 쉬워집니다.

```python
import pandas as pd
import numpy as np

class DataAnalyzer:
    """데이터 분석 워크플로우 캡슐화"""
    
    def __init__(self, filepath=None, df=None):
        if filepath:
            self.df = pd.read_csv(filepath)
        elif df is not None:
            self.df = df.copy()
        else:
            self.df = pd.DataFrame()
        
        self._report = {}
    
    @property
    def shape(self):
        return self.df.shape
    
    def summary(self):
        """기본 정보 출력"""
        print(f"행: {self.df.shape[0]}, 열: {self.df.shape[1]}")
        print(f"결측치: {self.df.isna().sum().sum()}")
        return self
    
    def clean(self):
        """결측치 제거"""
        before = len(self.df)
        self.df = self.df.dropna()
        after = len(self.df)
        print(f"결측치 제거: {before - after}행 삭제")
        return self   # 메서드 체이닝 가능
    
    def get_stats(self, column):
        """특정 열 통계"""
        series = self.df[column]
        return {
            'mean': series.mean(),
            'std': series.std(),
            'min': series.min(),
            'max': series.max()
        }

# 메서드 체이닝으로 사용
analyzer = DataAnalyzer(df=pd.DataFrame({
    'score': [85, 92, None, 78, 90]
}))

analyzer.summary().clean().summary()
```

---

## 7.7 실습: 학생 성적 관리 클래스

### 7.7.1 요구사항

지금까지 배운 클래스 개념을 종합해서 학생 성적 관리 시스템을 만들어봅시다.

- `Person`: 기본 인물 정보
- `Student`: Person을 상속, 성적 관리 기능 추가
- `Classroom`: 여러 Student를 관리

### 7.7.2 코드 작성

`grade_system.py` 파일을 만들고 다음 코드를 작성합니다.

```python
"""
클래스 기반 학생 성적 관리 시스템
"""


class Person:
    """기본 인물 클래스"""
    
    def __init__(self, name, age):
        self.name = name
        self._age = age
    
    @property
    def age(self):
        return self._age
    
    @age.setter
    def age(self, value):
        if not isinstance(value, int) or value < 0:
            raise ValueError(f"유효하지 않은 나이: {value}")
        self._age = value
    
    def __str__(self):
        return f"{self.name} ({self._age}세)"
    
    def __repr__(self):
        return f"Person(name='{self.name}', age={self._age})"


class Student(Person):
    """학생 클래스: Person을 상속"""
    
    school = "파이썬 아카데미"   # 클래스 속성
    _total_count = 0
    
    def __init__(self, name, age, student_id, grade=1):
        super().__init__(name, age)
        self.student_id = student_id
        self.grade = grade
        self._scores = {}   # 과목: 점수 딕셔너리
        Student._total_count += 1
    
    @classmethod
    def get_total_count(cls):
        """전체 학생 수 반환"""
        return cls._total_count
    
    @staticmethod
    def is_valid_score(score):
        """점수 유효성 검사"""
        return isinstance(score, (int, float)) and 0 <= score <= 100
    
    def add_score(self, subject, score):
        """과목 점수 추가"""
        if not Student.is_valid_score(score):
            raise ValueError(f"유효하지 않은 점수: {score}")
        self._scores[subject] = score
        return self   # 메서드 체이닝
    
    def get_score(self, subject):
        """과목 점수 조회"""
        return self._scores.get(subject, None)
    
    @property
    def average(self):
        """전체 평균 (읽기 전용)"""
        if not self._scores:
            return 0.0
        return sum(self._scores.values()) / len(self._scores)
    
    @property
    def grade_letter(self):
        """등급 (읽기 전용)"""
        avg = self.average
        if avg >= 90: return 'A'
        elif avg >= 80: return 'B'
        elif avg >= 70: return 'C'
        elif avg >= 60: return 'D'
        else: return 'F'
    
    @property
    def is_passing(self):
        """합격 여부 (읽기 전용)"""
        return self.average >= 60
    
    def get_report(self):
        """성적표 출력"""
        print(f"\n{'=' * 40}")
        print(f"성적표: {self.name} (학번: {self.student_id})")
        print(f"{'=' * 40}")
        
        for subject, score in self._scores.items():
            print(f"  {subject:10}: {score:5.1f}점")
        
        print(f"{'─' * 40}")
        print(f"  {'평균':10}: {self.average:5.1f}점")
        print(f"  {'등급':10}: {self.grade_letter}등급")
        print(f"  {'합격여부':10}: {'합격' if self.is_passing else '불합격'}")
        print(f"{'=' * 40}")
    
    def __str__(self):
        return f"Student({self.name}, {self.grade}학년, 평균: {self.average:.1f})"
    
    def __repr__(self):
        return (f"Student(name='{self.name}', age={self.age}, "
                f"student_id='{self.student_id}', grade={self.grade})")
    
    def __eq__(self, other):
        if not isinstance(other, Student):
            return False
        return self.student_id == other.student_id


class Classroom:
    """학급 클래스: 여러 학생 관리"""
    
    def __init__(self, class_name, teacher_name):
        self.class_name = class_name
        self.teacher_name = teacher_name
        self._students = []
    
    def add_student(self, student):
        """학생 추가"""
        if not isinstance(student, Student):
            raise TypeError("Student 인스턴스만 추가 가능합니다")
        if student in self._students:
            print(f"{student.name}은 이미 등록된 학생입니다")
            return self
        self._students.append(student)
        return self
    
    def remove_student(self, student_id):
        """학번으로 학생 삭제"""
        for i, student in enumerate(self._students):
            if student.student_id == student_id:
                removed = self._students.pop(i)
                print(f"{removed.name} 학생을 삭제했습니다")
                return True
        print(f"학번 {student_id}를 찾을 수 없습니다")
        return False
    
    def find_student(self, student_id):
        """학번으로 학생 검색"""
        for student in self._students:
            if student.student_id == student_id:
                return student
        return None
    
    def get_class_average(self, subject=None):
        """학급 평균 계산"""
        if not self._students:
            return 0.0
        
        if subject:
            scores = [
                s.get_score(subject)
                for s in self._students
                if s.get_score(subject) is not None
            ]
            return sum(scores) / len(scores) if scores else 0.0
        else:
            averages = [s.average for s in self._students]
            return sum(averages) / len(averages)
    
    def get_top_students(self, n=3):
        """상위 n명 반환"""
        sorted_students = sorted(
            self._students,
            key=lambda s: s.average,
            reverse=True
        )
        return sorted_students[:n]
    
    def get_failing_students(self):
        """불합격 학생 반환"""
        return [s for s in self._students if not s.is_passing]
    
    def print_class_report(self):
        """학급 전체 성적표"""
        print(f"\n{'=' * 60}")
        print(f"학급: {self.class_name}  |  담임: {self.teacher_name}")
        print(f"총 학생 수: {len(self)}명")
        print(f"{'=' * 60}")
        print(f"{'이름':<10} {'학년':<5} {'평균':<8} {'등급':<5} {'합격':<5}")
        print(f"{'─' * 60}")
        
        sorted_students = sorted(
            self._students,
            key=lambda s: s.average,
            reverse=True
        )
        
        for student in sorted_students:
            status = "✓" if student.is_passing else "✗"
            print(
                f"{student.name:<10} "
                f"{student.grade}학년   "
                f"{student.average:<8.1f} "
                f"{student.grade_letter}등급   "
                f"{status}"
            )
        
        print(f"{'─' * 60}")
        print(f"학급 평균: {self.get_class_average():.1f}점")
        
        failing = self.get_failing_students()
        if failing:
            print(f"불합격 학생: {', '.join(s.name for s in failing)}")
        else:
            print("전원 합격")
        
        print(f"{'=' * 60}")
    
    def __len__(self):
        return len(self._students)
    
    def __str__(self):
        return f"Classroom({self.class_name}, {len(self)}명)"
    
    def __repr__(self):
        return (f"Classroom(class_name='{self.class_name}', "
                f"teacher_name='{self.teacher_name}')")


# 메인 프로그램
if __name__ == "__main__":
    print("학생 성적 관리 시스템 시작\n")
    
    # 학생 생성
    alice = Student("Alice", 20, "S001", grade=2)
    bob = Student("Bob", 21, "S002", grade=2)
    charlie = Student("Charlie", 19, "S003", grade=1)
    diana = Student("Diana", 22, "S004", grade=3)
    eve = Student("Eve", 20, "S005", grade=2)
    
    # 점수 입력 (메서드 체이닝)
    alice.add_score("수학", 85).add_score("영어", 92).add_score("과학", 78)
    bob.add_score("수학", 92).add_score("영어", 88).add_score("과학", 95)
    charlie.add_score("수학", 55).add_score("영어", 62).add_score("과학", 58)
    diana.add_score("수학", 95).add_score("영어", 98).add_score("과학", 96)
    eve.add_score("수학", 88).add_score("영어", 85).add_score("과학", 90)
    
    # 학급 생성 및 학생 추가
    classroom = Classroom("Python반", "김선생님")
    classroom.add_student(alice)
    classroom.add_student(bob)
    classroom.add_student(charlie)
    classroom.add_student(diana)
    classroom.add_student(eve)
    
    # 1. 전체 성적표
    classroom.print_class_report()
    
    # 2. 개인 성적표
    alice.get_report()
    
    # 3. 상위 3명
    print("\n상위 3명:")
    for i, student in enumerate(classroom.get_top_students(3), 1):
        print(f"  {i}위: {student.name} ({student.average:.1f}점)")
    
    # 4. 불합격 학생
    failing = classroom.get_failing_students()
    print(f"\n불합격 학생: {len(failing)}명")
    for student in failing:
        print(f"  - {student.name}: {student.average:.1f}점")
    
    # 5. 과목별 평균
    print("\n과목별 학급 평균:")
    for subject in ["수학", "영어", "과학"]:
        avg = classroom.get_class_average(subject)
        print(f"  {subject}: {avg:.1f}점")
    
    # 6. 전체 학생 수 (클래스 메서드)
    print(f"\n총 생성된 학생 수: {Student.get_total_count()}명")
```

실행 결과:

```
학생 성적 관리 시스템 시작

============================================================
학급: Python반  |  담임: 김선생님
총 학생 수: 5명
============================================================
이름       학년  평균      등급  합격
────────────────────────────────────────────────────────────
Diana      3학년   96.3     A등급  ✓
Bob        2학년   91.7     A등급  ✓
Eve        2학년   87.7     B등급  ✓
Alice      2학년   85.0     B등급  ✓
Charlie    1학년   58.3     F등급  ✗
────────────────────────────────────────────────────────────
학급 평균: 83.7점
불합격 학생: Charlie
============================================================

========================================
성적표: Alice (학번: S001)
========================================
  수학      :  85.0점
  영어      :  92.0점
  과학      :  78.0점
────────────────────────────────────────
  평균      :  85.0점
  등급      : B등급
  합격여부  : 합격
========================================

상위 3명:
  1위: Diana (96.3점)
  2위: Bob (91.7점)
  3위: Eve (87.7점)

불합격 학생: 1명
  - Charlie: 58.3점

과목별 학급 평균:
  수학: 83.0점
  영어: 85.0점
  과학: 83.4점

총 생성된 학생 수: 5명
```

### 7.7.3 확장과 개선

이 시스템에 추가할 수 있는 기능들:

```python
# 1. ExchangeStudent: 교환 학생 (Student 상속)
class ExchangeStudent(Student):
    def __init__(self, name, age, student_id, country, grade=1):
        super().__init__(name, age, student_id, grade)
        self.country = country
    
    def __str__(self):
        return f"ExchangeStudent({self.name}, {self.country})"

# 2. 파일 저장/불러오기
import json

class Classroom:
    def save(self, filepath):
        data = {
            "class_name": self.class_name,
            "teacher_name": self.teacher_name,
            "students": [
                {
                    "name": s.name,
                    "age": s.age,
                    "student_id": s.student_id,
                    "grade": s.grade,
                    "scores": s._scores
                }
                for s in self._students
            ]
        }
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        print(f"{filepath}에 저장 완료")
```

**AI 활용 팁:**

클래스 설계를 마친 후 AI에게 리뷰를 요청하세요.

"이 Student, Classroom 클래스 설계를 리뷰해줘. 개선할 점이나 빠진 예외 처리가 있으면 알려줘"

AI가 점검할 수 있는 사항들:

- 예외 처리가 충분한지
- 메서드 이름이 직관적인지
- 중복 코드가 있는지
- 더 적합한 자료구조가 있는지
- Docstring이 충분한지

---

**이 장에서 배운 것:**

- **클래스의 필요성:** 데이터와 기능의 결합, 코드 재사용, 구조화
- **기본 구조:** `class`, `__init__`, `self`, 인스턴스 생성
- **속성과 메서드:** 인스턴스/클래스 속성, 인스턴스/클래스/정적 메서드
- **특수 메서드:** `__str__`, `__repr__`, `__len__`, `__eq__`
- **상속:** 부모/자식 클래스, `super()`, 메서드 오버라이딩
- **캡슐화:** 접근 제어 관례, `@property`로 유효성 검사
- **데이터 분석 연계:** scikit-learn과 Pandas의 클래스 기반 API 이해
- **실습:** Person → Student → Classroom의 계층 구조 구현

---

**전체 교재를 마치며:**

이 책에서는 파이썬 기초를 다음 순서로 학습했습니다.

0장에서 개발 환경을 구축하고, 1장에서 변수와 기본 문법을, 2장에서 리스트와 딕셔너리 같은 자료구조를 배웠습니다. 3장의 제어문과 4장의 함수를 통해 프로그램다운 프로그램을 만들 수 있게 되었고, 5장의 NumPy·Pandas를 통해 데이터를 직접 다루어봤습니다. 6장에서 파일 입출력으로 데이터를 영구 저장하는 방법을, 7장에서는 클래스를 통해 복잡한 시스템을 구조화하는 방법을 익혔습니다.

