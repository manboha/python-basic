
# 4. 함수

---

## 4.1 함수란 무엇인가

지금까지 배운 내용으로 상당히 복잡한 프로그램을 작성할 수 있습니다. 하지만 프로그램이 길어지면 문제가 생깁니다. 같은 코드가 여러 곳에서 반복되는 것입니다.

예를 들어 학생 성적의 평균을 계산하는 코드를 생각해봅시다.

```python
# Alice의 평균
alice_scores = [85, 92, 78]
alice_total = 0
for score in alice_scores:
    alice_total += score
alice_average = alice_total / len(alice_scores)

# Bob의 평균
bob_scores = [92, 88, 95]
bob_total = 0
for score in bob_scores:
    bob_total += score
bob_average = bob_total / len(bob_scores)

# Charlie의 평균
charlie_scores = [78, 85, 80]
charlie_total = 0
for score in charlie_scores:
    charlie_total += score
charlie_average = charlie_total / len(charlie_scores)
```

같은 패턴이 세 번 반복됩니다. 학생이 100명이라면? 이런 방식은 비효율적이고, 오류가 발생하기 쉽습니다. 계산 방식을 바꾸려면 모든 곳을 수정해야 합니다.

**함수(function)**는 이 문제를 해결합니다. 특정 작업을 수행하는 코드를 하나의 이름 있는 블록으로 묶어서, 필요할 때마다 재사용할 수 있게 만듭니다.

```python
def calculate_average(scores):
    total = sum(scores)
    return total / len(scores)

alice_average = calculate_average([85, 92, 78])
bob_average = calculate_average([92, 88, 95])
charlie_average = calculate_average([78, 85, 80])
```

코드가 훨씬 간결해지고, 평균 계산 방식을 바꾸려면 `calculate_average` 함수만 수정하면 됩니다.

**함수의 개념:**

함수는 **입력(input)**을 받아 **처리(process)**하고 **출력(output)**을 내놓는 상자입니다. 수학의 함수와 비슷합니다.

```
입력(scores) → [함수: 평균 계산] → 출력(average)
```

**함수를 사용하는 이유:**

1. **코드 재사용:** 같은 코드를 반복 작성하지 않음
2. **유지보수 용이:** 한 곳만 수정하면 모든 곳에 반영
3. **가독성 향상:** 복잡한 코드를 의미 있는 이름으로 추상화
4. **테스트 용이:** 함수 단위로 테스트 가능
5. **협업 효율:** 다른 사람이 만든 함수를 사용 가능

**Python의 함수:**

- **내장 함수(built-in function):** Python이 기본 제공 (`print()`, `len()`, `sum()`, `type()` 등)
- **사용자 정의 함수:** 우리가 직접 만드는 함수

---

## 4.2 함수의 기본 구조

### 4.2.1 함수 정의와 호출

함수는 `def` 키워드로 정의합니다.

```python
def greet():
    print("안녕하세요!")
```

**문법 구조:**

```python
def 함수이름(매개변수):
    실행할 코드
    return 반환값
```

- **`def`:** 함수 정의 시작
- **함수 이름:** 변수 이름 규칙과 동일 (snake_case 권장)
- **매개변수(parameter):** 함수가 받을 입력 (없을 수도 있음)
- **콜론(`:`):** 함수 본문 시작
- **들여쓰기:** 함수 본문은 반드시 들여쓰기
- **`return`:** 결과 값 반환 (선택사항)

**함수 호출:**

함수를 정의한 후, 이름 뒤에 괄호를 붙여 호출합니다.

```python
greet()   # 출력: 안녕하세요!
```

**매개변수와 인자:**

함수에 값을 전달할 수 있습니다.

```python
def greet(name):
    print(f"안녕하세요, {name}님!")

greet("Alice")   # 출력: 안녕하세요, Alice님!
greet("Bob")     # 출력: 안녕하세요, Bob님!
```

- **매개변수(parameter):** 함수 정의에서 `name` (받는 쪽)
- **인자(argument):** 함수 호출에서 `"Alice"` (주는 쪽)

**`return` 문:**

함수가 결과 값을 반환하게 합니다.

```python
def add(a, b):
    result = a + b
    return result

sum_value = add(3, 5)
print(sum_value)   # 8
```

### 4.2.2 함수 실행 흐름

함수 호출 시 일어나는 일:

1. 현재 실행 위치를 기억
2. 함수로 이동
3. 매개변수에 인자 값 할당
4. 함수 본문 실행
5. `return`을 만나면 값을 반환하고 함수 종료
6. 호출했던 위치로 돌아가서 다음 코드 실행

```python
def multiply(x, y):
    print(f"{x} × {y} 계산 중...")
    result = x * y
    return result

print("시작")
answer = multiply(3, 4)
print(f"결과: {answer}")
print("종료")
```

출력:

```
시작
3 × 4 계산 중...
결과: 12
종료
```

**반환 값이 없는 함수:**

`return` 문이 없거나 `return`만 쓰면 `None`을 반환합니다.

```python
def say_hello():
    print("Hello!")

result = say_hello()
print(result)   # None
```

`None`은 "값이 없음"을 나타내는 특별한 값입니다.

### 4.2.3 첫 함수 작성

**인사 함수:**

```python
def greet_person(name, age):
    message = f"안녕하세요, {name}님! {age}살이시군요."
    return message

greeting = greet_person("Alice", 20)
print(greeting)
```

출력:

```
안녕하세요, Alice님! 20살이시군요.
```

**계산 함수:**

```python
def calculate_circle_area(radius):
    pi = 3.14159
    area = pi * radius ** 2
    return area

area1 = calculate_circle_area(5)
area2 = calculate_circle_area(10)

print(f"반지름 5: {area1:.2f}")
print(f"반지름 10: {area2:.2f}")
```

출력:

```
반지름 5: 78.54
반지름 10: 314.16
```

**AI 활용 팁:**

함수를 어떻게 설계해야 할지 고민될 때 AI에게 물어보세요.

"학생 성적 관리 프로그램에서 어떤 함수들이 필요할까요?"

AI가 제안할 수 있는 함수들:

- `calculate_average(scores)`: 평균 계산
- `get_grade(score)`: 점수를 등급으로 변환
- `find_top_student(students)`: 최고 점수 학생 찾기
- `filter_passing_students(students, threshold)`: 합격자 필터링

---

## 4.3 매개변수와 인자

### 4.3.1 위치 인자

매개변수는 순서대로 인자와 매칭됩니다.

```python
def introduce(name, age, city):
    print(f"{name}은 {age}살이고 {city}에 삽니다")

introduce("Alice", 20, "서울")
```

출력:

```
Alice은 20살이고 서울에 삽니다
```

순서를 바꾸면 잘못된 결과가 나옵니다.

```python
introduce("서울", 20, "Alice")
```

출력:

```
서울은 20살이고 Alice에 삽니다
```

**인자 개수 불일치:**

매개변수 개수와 인자 개수가 다르면 에러가 발생합니다.

```python
introduce("Alice", 20)   # TypeError: missing 1 required positional argument
```

### 4.3.2 기본값 매개변수

매개변수에 기본값을 지정하면 인자를 생략할 수 있습니다.

```python
def greet(name, greeting="안녕하세요"):
    print(f"{greeting}, {name}님!")

greet("Alice")                    # 안녕하세요, Alice님!
greet("Bob", "좋은 아침입니다")    # 좋은 아침입니다, Bob님!
```

**기본값의 위치 제약:**

기본값이 있는 매개변수는 기본값이 없는 매개변수 뒤에 와야 합니다.

```python
# 올바른 예
def create_user(name, age, country="Korea"):
    pass

# 잘못된 예
def create_user(name, country="Korea", age):   # SyntaxError
    pass
```

**여러 기본값:**

```python
def make_profile(name, age=None, city=None, job=None):
    profile = f"이름: {name}"
    if age:
        profile += f", 나이: {age}"
    if city:
        profile += f", 도시: {city}"
    if job:
        profile += f", 직업: {job}"
    return profile

print(make_profile("Alice"))
print(make_profile("Bob", age=25))
print(make_profile("Charlie", age=30, city="서울", job="개발자"))
```

출력:

```
이름: Alice
이름: Bob, 나이: 25
이름: Charlie, 나이: 30, 도시: 서울, 직업: 개발자
```

### 4.3.3 키워드 인자

인자를 매개변수 이름으로 지정하면 순서를 바꿀 수 있습니다.

```python
def introduce(name, age, city):
    print(f"{name}은 {age}살이고 {city}에 삽니다")

introduce(city="서울", name="Alice", age=20)
```

출력:

```
Alice은 20살이고 서울에 삽니다
```

**위치 인자와 혼용:**

위치 인자가 먼저, 키워드 인자가 나중에 와야 합니다.

```python
introduce("Alice", city="서울", age=20)   # 올바름
introduce(name="Alice", 20, "서울")       # SyntaxError
```

**활용:**

매개변수가 많을 때 가독성을 높입니다.

```python
def send_email(to, subject, body, cc=None, bcc=None, priority="normal"):
    pass

# 명확함
send_email(
    to="alice@example.com",
    subject="회의 안내",
    body="내일 오전 10시 회의가 있습니다",
    priority="high"
)
```

### 4.3.4 가변 인자

**`*args`: 임의 개수의 위치 인자**

인자 개수를 미리 알 수 없을 때 사용합니다.

```python
def sum_all(*numbers):
    total = 0
    for num in numbers:
        total += num
    return total

print(sum_all(1, 2, 3))           # 6
print(sum_all(1, 2, 3, 4, 5))     # 15
print(sum_all(10, 20))            # 30
```

`*args`는 튜플로 받아집니다.

```python
def print_args(*args):
    print(type(args))   # <class 'tuple'>
    print(args)

print_args(1, 2, 3)   # (1, 2, 3)
```

**`**kwargs`: 임의 개수의 키워드 인자**

```python
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=20, city="서울")
```

출력:

```
name: Alice
age: 20
city: 서울
```

`**kwargs`는 딕셔너리로 받아집니다.

**혼용:**

```python
def make_pizza(size, *toppings, **details):
    print(f"크기: {size}")
    print(f"토핑: {toppings}")
    print(f"추가 정보: {details}")

make_pizza("Large", "페퍼로니", "치즈", "올리브", 
           crust="thin", sauce="tomato")
```

출력:

```
크기: Large
토핑: ('페퍼로니', '치즈', '올리브')
추가 정보: {'crust': 'thin', 'sauce': 'tomato'}
```

**언패킹 연산자:**

리스트나 딕셔너리를 풀어서 인자로 전달할 수 있습니다.

```python
def add(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
result = add(*numbers)   # add(1, 2, 3)과 동일
print(result)   # 6
```

```python
def introduce(name, age, city):
    print(f"{name}, {age}, {city}")

person = {"name": "Alice", "age": 20, "city": "서울"}
introduce(**person)   # introduce(name="Alice", age=20, city="서울")
```

---

## 4.4 반환 값

### 4.4.1 단일 값 반환

`return` 문은 함수를 즉시 종료하고 값을 반환합니다.

```python
def square(x):
    return x ** 2

result = square(5)
print(result)   # 25
```

**반환 후 함수 종료:**

`return` 이후의 코드는 실행되지 않습니다.

```python
def check_positive(num):
    if num > 0:
        return "양수입니다"
    
    return "양수가 아닙니다"
    print("이 줄은 실행되지 않습니다")   # 도달 불가능한 코드

print(check_positive(5))    # 양수입니다
print(check_positive(-3))   # 양수가 아닙니다
```

### 4.4.2 여러 값 반환

여러 값을 반환하려면 튜플을 사용합니다. Python은 자동으로 튜플로 묶어줍니다.

```python
def get_min_max(numbers):
    return min(numbers), max(numbers)

result = get_min_max([3, 1, 4, 1, 5])
print(result)   # (1, 5)
print(type(result))   # <class 'tuple'>
```

**언패킹으로 받기:**

```python
minimum, maximum = get_min_max([3, 1, 4, 1, 5])
print(f"최솟값: {minimum}, 최댓값: {maximum}")
```

출력:

```
최솟값: 1, 최댓값: 5
```

**여러 통계 값 반환:**

```python
def calculate_statistics(numbers):
    total = sum(numbers)
    count = len(numbers)
    average = total / count
    minimum = min(numbers)
    maximum = max(numbers)
    
    return total, average, minimum, maximum

scores = [85, 92, 78, 90, 88]
total, avg, min_score, max_score = calculate_statistics(scores)

print(f"합계: {total}")
print(f"평균: {avg:.2f}")
print(f"최저: {min_score}")
print(f"최고: {max_score}")
```

### 4.4.3 조건부 반환

여러 개의 `return` 문을 사용해 조건에 따라 다른 값을 반환할 수 있습니다.

```python
def get_grade(score):
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"

print(get_grade(85))   # B
print(get_grade(72))   # C
```

**조기 반환(early return) 패턴:**

유효성 검사를 먼저 하고 조기에 반환하면 코드가 깔끔해집니다.

```python
def divide(a, b):
    if b == 0:
        return "0으로 나눌 수 없습니다"
    
    return a / b

print(divide(10, 2))   # 5.0
print(divide(10, 0))   # 0으로 나눌 수 없습니다
```

중첩 if를 피할 수 있습니다.

```python
# 나쁜 예 (중첩)
def process_data(data):
    if data is not None:
        if len(data) > 0:
            if data[0] > 0:
                return data[0] * 2
    return None

# 좋은 예 (조기 반환)
def process_data(data):
    if data is None:
        return None
    if len(data) == 0:
        return None
    if data[0] <= 0:
        return None
    
    return data[0] * 2
```

---

## 4.5 변수의 스코프

### 4.5.1 지역 변수와 전역 변수

**지역 변수(local variable):** 함수 내부에서 정의된 변수. 함수 밖에서는 접근 불가.

```python
def my_function():
    local_var = 10
    print(local_var)

my_function()   # 10
print(local_var)   # NameError: name 'local_var' is not defined
```

**전역 변수(global variable):** 함수 밖에서 정의된 변수. 함수 내부에서 읽을 수 있음.

```python
global_var = 100

def my_function():
    print(global_var)   # 전역 변수 읽기 가능

my_function()   # 100
```

**주의: 함수 내에서 전역 변수와 같은 이름으로 할당하면 지역 변수가 됩니다.**

```python
count = 0

def increment():
    count = 1   # 새로운 지역 변수 생성
    print(f"함수 내부: {count}")

increment()   # 함수 내부: 1
print(f"전역: {count}")   # 전역: 0
```

### 4.5.2 `global` 키워드

함수 내부에서 전역 변수를 수정하려면 `global` 키워드를 사용합니다.

```python
count = 0

def increment():
    global count
    count += 1
    print(f"함수 내부: {count}")

increment()   # 함수 내부: 1
print(f"전역: {count}")   # 전역: 1
increment()   # 함수 내부: 2
print(f"전역: {count}")   # 전역: 2
```

**사용 시 주의사항:**

`global`은 코드를 이해하기 어렵게 만들 수 있습니다. 가능하면 피하고, 매개변수와 반환 값으로 데이터를 주고받으세요.

```python
# 나쁜 예 (global 사용)
total = 0

def add_to_total(value):
    global total
    total += value

add_to_total(10)
add_to_total(20)
print(total)   # 30

# 좋은 예 (매개변수와 반환)
def add(current_total, value):
    return current_total + value

total = 0
total = add(total, 10)
total = add(total, 20)
print(total)   # 30
```

### 4.5.3 네임스페이스

Python은 변수를 찾을 때 **LEGB 규칙**을 따릅니다.

1. **Local:** 함수 내부
2. **Enclosing:** 중첩 함수의 바깥 함수
3. **Global:** 모듈 전역
4. **Built-in:** Python 내장

```python
x = "global"

def outer():
    x = "enclosing"
    
    def inner():
        x = "local"
        print(x)   # local
    
    inner()
    print(x)   # enclosing

outer()
print(x)   # global
```

**내장 이름 덮어쓰기 주의:**

```python
# 나쁜 예
list = [1, 2, 3]   # 내장 함수 list를 변수로 사용
my_list = list([4, 5, 6])   # TypeError: 'list' object is not callable
```

내장 함수명(`list`, `dict`, `sum`, `max` 등)을 변수명으로 사용하지 마세요.

---

## 4.6 람다 함수

### 4.6.1 람다 함수의 개념

람다 함수는 이름 없는 **익명 함수(anonymous function)**입니다. 간단한 연산을 한 줄로 표현할 때 사용합니다.

```python
# 일반 함수
def square(x):
    return x ** 2

# 람다 함수
square_lambda = lambda x: x ** 2

print(square(5))          # 25
print(square_lambda(5))   # 25
```

**문법:**

```python
lambda 매개변수: 표현식
```

- 매개변수는 여러 개 가능
- 표현식은 하나만 (한 줄)
- `return` 키워드 없이 자동 반환

**여러 매개변수:**

```python
add = lambda a, b: a + b
print(add(3, 5))   # 8

multiply = lambda x, y, z: x * y * z
print(multiply(2, 3, 4))   # 24
```

### 4.6.2 람다 함수 활용

람다 함수는 주로 다른 함수의 인자로 전달할 때 사용합니다. 대표적으로 `map()`, `filter()`, `sorted()`와 함께 자주 사용됩니다.

**`map()`: 모든 요소에 함수 적용**

```python
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)   # [1, 4, 9, 16, 25]
```

**`filter()`: 조건에 맞는 요소만 필터링**

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)   # [2, 4, 6, 8, 10]
```

**`sorted()`: 정렬 기준 지정**

```python
students = [
    {"name": "Alice", "score": 85},
    {"name": "Bob", "score": 92},
    {"name": "Charlie", "score": 78}
]

# 점수로 정렬
sorted_students = sorted(students, key=lambda s: s["score"], reverse=True)

for student in sorted_students:
    print(f"{student['name']}: {student['score']}")
```

출력:

```
Bob: 92
Alice: 85
Charlie: 78
```

**간단한 연산에만 사용:**

람다는 한 줄로 표현 가능한 간단한 경우에만 사용하세요. 복잡하면 일반 함수를 쓰는 것이 좋습니다.

```python
# 나쁜 예 (복잡함)
result = lambda x: x * 2 if x > 0 else -x * 2 if x < 0 else 0

# 좋은 예 (명확함)
def process(x):
    if x > 0:
        return x * 2
    elif x < 0:
        return -x * 2
    else:
        return 0
```

---

## 4.7 고급 함수 기법

### 4.7.1 함수를 인자로 전달

Python에서 함수는 **일급 객체(first-class object)**입니다. 변수에 할당하고, 인자로 전달하고, 반환할 수 있습니다.

```python
def apply_operation(func, value):
    return func(value)

def square(x):
    return x ** 2

def cube(x):
    return x ** 3

print(apply_operation(square, 5))   # 25
print(apply_operation(cube, 5))     # 125
```

**콜백 함수 패턴:**

콜백 함수 패턴은 함수를 다른 함수의 인자로 전달하는 대표적인 방식입니다. "무엇을 할지"를 함수로 만들어 넘기는 것으로, 처리의 흐름은 고정하되 그 안에서 실행될 동작만 바깥에서 주입받습니다. 

아래 코드에서 `process_numbers`는 데이터와 함께 '각 항목에 적용할 함수'도 인자로 받습니다. 어떻게 처리할지를 호출하는 쪽에서 결정하는 구조입니다.

```python
def process_numbers(numbers, callback):
    result = []
    for num in numbers:
        processed = callback(num)
        result.append(processed)
    return result

def double(x):
    return x * 2

def triple(x):
    return x * 3

numbers = [1, 2, 3, 4, 5]
print(process_numbers(numbers, double))   # [2, 4, 6, 8, 10]
print(process_numbers(numbers, triple))   # [3, 6, 9, 12, 15]
```

### 4.7.2 함수에서 함수 반환

함수가 다른 함수를 만들어 반환할 수 있습니다.

```python
def make_multiplier(n):
    def multiplier(x):
        return x * n
    return multiplier

times_2 = make_multiplier(2)
times_3 = make_multiplier(3)

print(times_2(5))   # 10
print(times_3(5))   # 15
```

**클로저(closure):**

클로저(closure)는 내부 함수가 외부 함수의 변수를 기억하고 유지하는 구조입니다. 외부 함수가 실행을 마친 뒤에도, 내부 함수는 당시의 변수를 그대로 간직한 채 동작합니다.

아래 코드에서 `make_counter()`가 끝나면 `count`는 사라질 것처럼 보입니다. 그러나 반환된 `increment` 함수가 `count`를 참조하고 있기 때문에, Python은 이 변수를 메모리에서 유지합니다. 이것이 "기억한다"는 말의 실제 의미입니다.

`nonlocal`은 내부 함수에서 외부 함수의 변수를 단순히 읽는 것을 넘어, **값을 변경**할 때 필요합니다. 선언하지 않으면 Python은 `count += 1`을 내부 함수의 새 변수로 해석해 오류가 발생합니다.

```python
def make_counter():
    count = 0
    
    def increment():
        nonlocal count
        count += 1
        return count
    
    return increment

counter1 = make_counter()
counter2 = make_counter()

print(counter1())   # 1
print(counter1())   # 2
print(counter2())   # 1 (독립적인 카운터)
```

**팩토리 함수:**

팩토리 함수는 특정 설정을 고정한 채, 그 설정을 기억하는 새로운 함수를 만들어 반환하는 패턴입니다. 클로저의 "기억" 특성을 활용해, 매번 처음부터 설정을 지정하지 않아도 되는 함수를 찍어내듯 생성합니다.

아래 코드에서 `create_greeting("Hello")`를 호출하면, `"Hello"`를 기억하는 `greet` 함수가 반환됩니다. 이후 `say_hello("Alice")`를 호출할 때는 인사말을 다시 지정할 필요가 없습니다. `say_hello`와 `say_hi`는 각자 다른 `greeting`을 고정한 채 독립적으로 동작합니다.

```python
def create_greeting(greeting):
    def greet(name):
        return f"{greeting}, {name}!"
    return greet

say_hello = create_greeting("Hello")
say_hi = create_greeting("Hi")

print(say_hello("Alice"))   # Hello, Alice!
print(say_hi("Bob"))        # Hi, Bob!
```

### 4.7.3 재귀 함수

재귀 함수는 **자기 자신을 호출**하는 함수입니다.

**팩토리얼 예제:**

```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))   # 120
```

실행 과정:

```
factorial(5)
= 5 * factorial(4)
= 5 * 4 * factorial(3)
= 5 * 4 * 3 * factorial(2)
= 5 * 4 * 3 * 2 * factorial(1)
= 5 * 4 * 3 * 2 * 1
= 120
```

**종료 조건의 중요성:**

재귀 함수는 반드시 **종료 조건(base case)**이 있어야 합니다. 없으면 무한히 호출되어 스택 오버플로우 에러가 발생합니다.

```python
# 나쁜 예 (종료 조건 없음)
def infinite_recursion(n):
    return infinite_recursion(n - 1)   # RecursionError

# 좋은 예 (종료 조건 있음)
def countdown(n):
    if n <= 0:   # 종료 조건
        print("발사!")
    else:
        print(n)
        countdown(n - 1)

countdown(3)
```

출력:

```
3
2
1
발사!
```

**재귀 vs 반복문:**

대부분의 재귀는 반복문으로 바꿀 수 있습니다.

```python
# 재귀 버전
def factorial_recursive(n):
    if n <= 1:
        return 1
    return n * factorial_recursive(n - 1)

# 반복문 버전
def factorial_iterative(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

print(factorial_recursive(5))   # 120
print(factorial_iterative(5))   # 120
```

일반적으로 반복문이 더 효율적이지만, 재귀가 문제의 본질을 더 명확히 표현하는 경우도 있습니다 (예: 트리 구조 탐색, 분할 정복 알고리즘).

---

## 4.8 함수 설계 원칙

### 4.8.1 단일 책임 원칙

하나의 함수는 한 가지 일만 해야 합니다.

```python
# 나쁜 예 (여러 일을 함)
def process_and_save_data(data):
    # 데이터 검증
    if not data:
        return False
    
    # 데이터 변환
    processed = [d * 2 for d in data]
    
    # 평균 계산
    average = sum(processed) / len(processed)
    
    # 파일 저장
    with open("result.txt", "w") as f:
        f.write(str(average))
    
    return average

# 좋은 예 (각각의 함수로 분리)
def validate_data(data):
    return data is not None and len(data) > 0

def transform_data(data):
    return [d * 2 for d in data]

def calculate_average(data):
    return sum(data) / len(data)

def save_to_file(value, filename):
    with open(filename, "w") as f:
        f.write(str(value))

def process_data(data):
    if not validate_data(data):
        return None
    
    processed = transform_data(data)
    average = calculate_average(processed)
    save_to_file(average, "result.txt")
    
    return average
```

### 4.8.2 함수 이름 짓기

**동사로 시작:**

함수는 동작을 수행하므로 동사로 시작하는 것이 좋습니다.

- `calculate_average()` (좋음)
- `average()` (애매함)

**명확하고 구체적으로:**

- `process()` → `calculate_total_sales()`
- `get()` → `get_student_by_id()`
- `update()` → `update_user_email()`

**일관된 명명 규칙:**

- `get_`: 값을 가져옴
- `set_`: 값을 설정
- `is_`, `has_`: 불린 반환
- `calculate_`: 계산 수행
- `validate_`: 유효성 검사

### 4.8.3 문서화 문자열 (Docstring)

함수 첫 줄에 삼중 따옴표로 설명을 작성합니다.

```python
def calculate_bmi(weight, height):
    """
    체질량지수(BMI)를 계산합니다.
    
    Parameters:
        weight (float): 체중 (kg)
        height (float): 키 (m)
    
    Returns:
        float: BMI 값
    """
    return weight / (height ** 2)
```

`help()` 함수로 확인할 수 있습니다.

```python
help(calculate_bmi)
```

**Google 스타일 Docstring:**

```python
def get_grade(score):
    """점수를 등급으로 변환합니다.
    
    Args:
        score (int): 0-100 사이의 점수
    
    Returns:
        str: A, B, C, D, F 중 하나의 등급
    
    Examples:
        >>> get_grade(95)
        'A'
        >>> get_grade(72)
        'C'
    """
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
```

---

## 4.9 실습: 성적 처리 함수 라이브러리

### 4.9.1 요구사항

지금까지 배운 내용을 종합해서 성적 처리 관련 함수들을 만들어봅시다.

- 평균 계산 함수
- 등급 변환 함수
- 합격/불합격 판정 함수
- 최고/최저 점수 찾기 함수
- 통계 요약 함수

### 4.9.2 코드 작성

`grade_utils.py` 파일을 만들고 다음 코드를 작성합니다.

```python
"""
학생 성적 처리를 위한 유틸리티 함수 모음
"""

def calculate_average(scores):
    """점수 리스트의 평균을 계산합니다.
    
    Args:
        scores (list): 점수 리스트
    
    Returns:
        float: 평균 점수
    """
    if not scores:
        return 0
    return sum(scores) / len(scores)


def get_grade(score):
    """점수를 등급으로 변환합니다.
    
    Args:
        score (float): 점수 (0-100)
    
    Returns:
        str: 등급 (A, B, C, D, F)
    """
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"


def is_passing(score, threshold=60):
    """합격 여부를 판정합니다.
    
    Args:
        score (float): 점수
        threshold (float): 합격 기준 점수 (기본값: 60)
    
    Returns:
        bool: 합격 여부
    """
    return score >= threshold


def find_top_student(students):
    """최고 평균 점수를 가진 학생을 찾습니다.
    
    Args:
        students (dict): {이름: [점수들]} 형태의 딕셔너리
    
    Returns:
        tuple: (이름, 평균점수) 또는 None
    """
    if not students:
        return None
    
    top_name = None
    top_average = 0
    
    for name, scores in students.items():
        average = calculate_average(scores)
        if average > top_average:
            top_average = average
            top_name = name
    
    return top_name, top_average


def get_statistics(scores):
    """점수 리스트의 통계를 계산합니다.
    
    Args:
        scores (list): 점수 리스트
    
    Returns:
        dict: 평균, 최고, 최저, 합격자 수 등의 통계
    """
    if not scores:
        return {
            "count": 0,
            "average": 0,
            "max": 0,
            "min": 0,
            "passing_count": 0
        }
    
    average = calculate_average(scores)
    passing_count = sum(1 for score in scores if is_passing(score))
    
    return {
        "count": len(scores),
        "average": average,
        "max": max(scores),
        "min": min(scores),
        "passing_count": passing_count,
        "passing_rate": passing_count / len(scores) * 100
    }


def filter_by_grade(students, target_grade):
    """특정 등급 학생들만 필터링합니다.
    
    Args:
        students (dict): {이름: [점수들]} 형태의 딕셔너리
        target_grade (str): 찾을 등급
    
    Returns:
        list: 해당 등급 학생 이름 리스트
    """
    result = []
    
    for name, scores in students.items():
        average = calculate_average(scores)
        grade = get_grade(average)
        
        if grade == target_grade:
            result.append(name)
    
    return result


# 메인 프로그램
if __name__ == "__main__":
    print("=" * 60)
    print("성적 처리 시스템")
    print("=" * 60)
    
    # 테스트 데이터
    students = {
        "Alice": [85, 92, 78, 90, 88],
        "Bob": [92, 88, 95, 90, 91],
        "Charlie": [78, 75, 72, 80, 76],
        "Diana": [95, 98, 96, 94, 97],
        "Eve": [65, 70, 68, 72, 69]
    }
    
    # 1. 각 학생의 평균과 등급
    print("\n1. 학생별 성적:")
    for name, scores in students.items():
        average = calculate_average(scores)
        grade = get_grade(average)
        status = "합격" if is_passing(average) else "불합격"
        
        print(f"  {name}: 평균 {average:.2f}점, {grade}등급, {status}")
    
    # 2. 최고 학생
    print("\n2. 최고 성적 학생:")
    top_name, top_avg = find_top_student(students)
    print(f"  {top_name}: {top_avg:.2f}점")
    
    # 3. 전체 통계
    print("\n3. 전체 통계:")
    all_scores = []
    for scores in students.values():
        all_scores.extend(scores)
    
    stats = get_statistics(all_scores)
    print(f"  총 시험 횟수: {stats['count']}")
    print(f"  평균 점수: {stats['average']:.2f}")
    print(f"  최고 점수: {stats['max']}")
    print(f"  최저 점수: {stats['min']}")
    print(f"  합격 횟수: {stats['passing_count']} ({stats['passing_rate']:.1f}%)")
    
    # 4. A등급 학생
    print("\n4. A등급 학생:")
    a_students = filter_by_grade(students, "A")
    for name in a_students:
        print(f"  {name}")
    
    print("\n" + "=" * 60)
```

실행 결과:

```
============================================================
성적 처리 시스템
============================================================

1. 학생별 성적:
  Alice: 평균 86.60점, B등급, 합격
  Bob: 평균 91.20점, A등급, 합격
  Charlie: 평균 76.20점, C등급, 합격
  Diana: 평균 96.00점, A등급, 합격
  Eve: 평균 68.80점, D등급, 합격

2. 최고 성적 학생:
  Diana: 96.00점

3. 전체 통계:
  총 시험 횟수: 25
  평균 점수: 83.76
  최고 점수: 98
  최저 점수: 65
  합격 횟수: 25 (100.0%)

4. A등급 학생:
  Bob
  Diana

============================================================
```

### 4.9.3 테스트와 디버깅

각 함수를 개별적으로 테스트해봅시다.

```python
# 함수 테스트
print("calculate_average 테스트:")
print(calculate_average([80, 90, 100]))   # 90.0
print(calculate_average([]))              # 0

print("\nget_grade 테스트:")
print(get_grade(95))   # A
print(get_grade(85))   # B
print(get_grade(55))   # F

print("\nis_passing 테스트:")
print(is_passing(70))           # True
print(is_passing(50))           # False
print(is_passing(75, 80))       # False (기준 80)
```

**AI 활용 팁:**

함수를 작성한 후 AI에게 개선 제안을 받으세요.

"이 함수를 더 효율적으로 만들거나 가독성을 높일 방법이 있을까요?"

```python
def filter_by_grade(students, target_grade):
    result = []
    for name, scores in students.items():
        average = calculate_average(scores)
        grade = get_grade(average)
        if grade == target_grade:
            result.append(name)
    return result
```

AI가 제안할 수 있는 개선:

```python
# 리스트 컴프리헨션 사용
def filter_by_grade(students, target_grade):
    return [
        name for name, scores in students.items()
        if get_grade(calculate_average(scores)) == target_grade
    ]
```

---

**이 장에서 배운 것:**

- **함수의 개념:** 코드 재사용과 추상화
- **함수 정의:** `def` 키워드, 매개변수, `return`
- **매개변수 종류:** 위치 인자, 기본값, 키워드 인자, 가변 인자 (`*args`, `**kwargs`)
- **반환 값:** 단일/여러 값 반환, 조건부 반환
- **스코프:** 지역 변수, 전역 변수, LEGB 규칙
- **람다 함수:** 익명 함수와 `map()`, `filter()` 활용
- **고급 기법:** 함수를 인자로, 함수 반환, 재귀
- **설계 원칙:** 단일 책임, 명명 규칙, Docstring
- **실습:** 성적 처리 함수 라이브러리

**다음 장에서는:**

라이브러리와 모듈을 사용하는 방법을 배웁니다. 특히 NumPy와 Pandas 같은 데이터 분석 라이브러리의 기초를 다지며, 본격적으로 데이터를 다루는 단계로 진입합니다. 함수를 만들 수 있게 되었으니, 이제 다른 사람들이 만든 강력한 도구들을 활용할 차례입니다.